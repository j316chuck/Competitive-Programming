General Tips:
1) Seize the day, You CAN DO IT! State Champion, A+ CS61B, USACO Platinum
2) Remember your falls - USAMO, HS
3) Do harder Problems - 1 C problem maximum, 2 D's for concept, 3 E's FOCUS ON E PROBLEMS
4) Read the question carefully 3 minutes practice
5) Write solution without paper -> good notes/scratch
(I feel like your scratch work sucks more intution)
(Scratch for examples + pseudocode + jotting down ideas only)
6) You must take breaks every 2 - 3 hours. 
7) Code carefully -> minimize debugging. 
8) Editorial + Read 2 other people's solution carefully with the intent to learn something new!
9) Not about perfection but direction... 9/10 test cases = good on first try 


Tackling hard problem:
1) Solve the 1-dimensional version of the problem first.
2) find base cases
3) do small case examples
4) Make observations... 

Solutions of Good + Hard Problems: * = redo, ! = hard/tricky, x = 50% understand, o = did not implement

Problem: CF812D x (nchtr euler's formula + tin??)
Origin: http://codeforces.com/contest/812/problem/D
Learned: 1) Solve harder problems 2) read, show work, and think to do more in problems
3) take breaks 4) read other people's solution with intent to learn 5) rooted tree simplification
6) recognize that only last person linked matters 7) euler's size dfs. 

Problem: POJ 1654 (Triangle formula idea easy, implementation a little tricky)
Origin: http://poj.org/problem?id=1654
Learned: 1) MLE makes sense because CHUCK ... you cannot have 20 million x 2 doubles...
2) Algorithm correct = cool triangle formula to split polygons into triangle and use cross product to solve
3) Store only the points you need. 4) POJ sucks 5) 15 minutes debugging maximum 6) It's okay I give up lol

Problem: POJ 2242 (circle formula 3 points easy)
Origin: poj.org/problem?id=2242
Learned: 1) Formulas for circle yay. 2) Computational geometry -- angle bisector.

Problem: POJ 2084 (big integer practice recursion easy)
Origin: http://blog.csdn.net/jasison/article/details/8753814
Learned: 1) Java Big Integer practice 2) Catalan numbers recurrence relation cool!
3) Nice Big Integer C++ implementation... 

Problem: POJ 2693 (hard implementation easy geometric idea)
Origin: http://www.cnblogs.com/william-cheung/p/3641553.html
Learned: 1) Got all the edge cases surprisingly. 2) 2 UNIQUE circles. 3) Find perpendicular bisector ... and then solve
4) account for edge case with the distance being = to 2.5 5) bisector to line count... :D 6) May be easier if you keep point and line short and sweet;


Problem: POJ 2085! (2 realizations about minimum permutation)
Origin: http://poj.org/problem?id=2085
Learned: 1) Implementation Problems / Ad hoc = solve first with examples 2) define clear algorithms and implementations + examples
3) code fast + code with examples... 4) win!!! 5) If you are stuck -> list sample cases at least 5 then -> try to find a pattern! 
6) One line cute solution of just finding the minimum n + k and reverting order...

Problem: POJ 2356! (tricky bijection realization)
Origin: http://poj.org/problem?id=2356
Learned: 1) Smart solution!!! uses bijection. 2) Do examples -> realize that sum can always take up 1, 2, 3, ... n -1, 0 mod n; 
3) If it repeats the sum then that means that the solution exists between the previous value of the sum and this value. Else they will continue to be unique until you get too n
4) Good read + examples (work on examples -> observation) 4) Think how can I find a cleaner solution.


Problem: POJ 1426 (got it first try!) (bfs)
Origin: http://poj.org/problem?id=1426
Learned: 1) BFS can even simplify to just use long long with math approximations...
2) BFS = use map to keep integers make key observation that all 10 = x 10 + 1 and x 10 = iterate through and solve!!!


Problem: POJ 1148 (IOI 2002) (alternating signs)
Origin: http://poj.org/problem?id=1148 
Solution: http://www.ioinformatics.org/locations/ioi02/contest/day1/utopia/utopia-handout.pdf
Learned: 1) 10000 = should involve sorting 2) 2D break down into 1D problem 3) Realize that 
you cannot brute force it so you must find a smart solution... 4) Pattern of alternating signs and how you can always maintain + or - 
5)  Really smart way of alternating signs to keep + and - so that you can find xc and solve. :D 6) coding = dx dy simplification, then use functions to solve repeated parts, x and y etc.

Problem: POJ 1905 (binary search + math practice)
Origin: http://poj.org/problem?id=1905
Learned: 1) Perfectly imperfect, focus on rest, focus on work, treat it like contest, focus on learning
2) Do math quick... you can do the math faster. 3) Your binarysearch on answer is correct. For doubles it is really simple just keep on dividing
4) asin0 r0 = part of circle 5) d = ... d < 0 wrong!!! just do x < y EPS matters in computational geometry. 6) to make more precise do < EPS 3 digits more specific than what they ask 

Problem: POJ 2653 (queue + line segment practice)
Origin: http://poj.org/problem?id=2318
Learned: 1) Cool observation that there are only 1000 max results 2) Simplify's problem and use two vectors to insert and delete 
3) segment intersection borrow from stanford, or can also do two line intersection and check if the point lies on BOTH segments!!! :D
4) can also use a queue!!!

Problem: POJ 2318 (cross product + binary search)
Origin: http://poj.org/problem?id=2074
Learned: 1) In Box if cross product < 0 or clockwise if you go around the points in a polygon in a clockwise fashion for all the pairs of subsequent points O(mn) solution
2) can also use binary search to solve it faster in O(m log n) hi = n + 1 = always smaller, lo = 0 always bigger. 
3) Many ways to do test if a points is to the left or right of a line. best way = CCW or not. Or you can also do project point to line and compare x coordinates...
4) %lf coding be careful. Use binarysearch technique to debug...


Problem: POJ 1696 (cross product practice)
Origin: http://poj.org/problem?id=1696
Learned: 1) Use slow_hull idea to solve 2) q == -1, mindex, optimizations, keep on turning left. p, i, q. 
3) can also implement another way by having a sorting function and sorting every time by point. 

Problem: POJ 2074 (line segment intersection + sweep line / sorting)
Origin: http://poj.org/problem?id=2074
Learned: 1) Please read the problem 2) Please do the examples 3) Then try to solve the problem, else you are trying to solve an impossible problem... 
4) Practice not solving and feeling comfortable 5) right to left, left to right to make coordinates 6) then sort 7) then use max min loop to solve

Problem: POJ 2540 * (Intersecting half planes Implementation half way)
Origin: http://poj.org/problem?id=2540
Learned: 1) Implementation half way but good enough for now 2) Half Line intersectin problem
3) May be some bugs in my line_point_beta implementation... but good enough for now... 4) Got the general idea
that first we need to calculate perpendicular bisector of prev and next point. Then add this point to the lines.
5) Use CCW to determine if point is to the left or right of point, if so then switch the lines directions
6) Finally solve the intersection half points problem by doing O(n^3) to get points, then convex hull, then compute signed area.

Problem: POJ 1228 * (convex hull + collinear somehow messed up implementation whelp)
Origin: http://poj.org/problem?id=1228
Learned: 1) Treat it like a contest 45 min timer wow I did it so fast. Starting tmw. 
2) 11 sleep 3) I actually got the implementation details... use convex hull to mark the current polygon
4) Each line segment must have three points in it!!! :D 5) Slow way = first way = have old points and check if there are three points per pt = O(N^2)
5) fast way in O(N) = since your convex hull does not remove redundant you can check if three points are collinear in O(N) 

Problem: POJ 1408 (line line intersection + implementation) 
Origin: http://poj.org/problem?id=1408
Learned: 1) Treat it like a contest 2) Trust in your functions 3) Solved it in 1 hour and 30 min
4) Could have simplified implementation and just done double for loop. 5) Pretty easy problem with just
line line intersection and area calculation! :D 

Problem: POJ 1584 ! (point in polygon, convex, project point to line + implementation)
Origin: http://poj.org/problem?id=1584
Learned: 1) Missed edge case of point being outside of peg. 2) Got the other two conditions that polygon has to be convex and 
point projected onto polygon has to be > than radius 3) Good consistent 2 hour, hard work, + no implementation = learning!!! 
4) Point projection easy, convex easy orientation, pt in convex polygon easy orientation, pt in nonconvex polygon a little harder = use stanford solution
5) *** note you are not given ordering of polygon (counterclockwise or clockwise)...  (tmp sign) 

Codeforces Round 419 Learned:
1) 11 - 6 AM consistent  
2) Work hard 2 hour sessions like contest
3) Work smart... people don't spend as much time but they do better because they don't train dumb
4) Problem = contest daily + learning not coding + 2 hour coding session 
5) Coding tips: read question twice, think (no writing), when solving right before you code you must spend 3 min checking if you missed any edge cases or can simplify code.
then, when you get WA reread question seeing if you missed anything (carefully), then -> go and resolve/recheck algorithm


Problem: Codeforces 419A
Origin: http://codeforces.com/contest/816/problem/A
Learned: 1) scanf("%d:%d") to read in input 2) increment counter until you get a valid palindrome 3) should solve in < 10 min

Problem: Codeforces 419B
Origin: http://codeforces.com/contest/816/problem/B
Learned: Got right idea, used set implementation which obfuscated the material. Could have
done a very simple implementation of using a[i]++, and c[i] = c[i-1] + (p[i]>=k);

Problem: Codeforces 419C
Origin: http://codeforces.com/blog/entry/52742
Learned: 1) Right implementation idea, use greedy to decrease until 0 then iterate and solve
2) Please be careful about implementation though... make sure to check edge case cause it's minimum # of row, column
(faster please)

Problem: Codeforces 419D *!o
Origin: http://codeforces.com/contest/815/problem/B
Learned: 1) Brute force method... print out all the values of n = 1, 2, 3,.. with the values 0, 0, 0, 1, 0, 0, 0
This can produce an easy brute force solution based on n mod 4. (last case 10 min brute force 10 min solve 10 min code) 
2) Cool method: 1) realize how easy addition easy -> contribution per item is (n-1) C (k-1). 2) Simplify task to all even 
such that it becomes + - + - + - with even number of tasks. Can just brute force this. 3) Even tasks can be solved by dividing it into
groups a1, a3, a5 etc... and a2, a4, a6... and it simplifies to the easy addition case.  4) wrote invfactorial method and factorial mod method


Problem: POJ 3525 !x
Learned: 1) HalfPoint intersection, can represent in counteclockwise manner as 2 points.
2) binary search while (r - l > eps) or for (; i < 100; i++) (me gusta second option)
3) HalfPlane intersection O(nlogn)  = clear pass = implement later or (O(n^3)) can also pass
4) Check if the halfplane intersection of the newly created polygon is 0 or not.
5) to create line you do double dx = (a.y - b.y)*p/len;
	double dy = (b.x - a.x) * p /len; x" = x + dx, y" = y + dy;  6) halfplane = two point representation...
	(use simple cases to deduce sign and this is because of perpendicular lines)
6) When implementing... be very careful... when debugging = first re read if you are wrong, then go step by step
and see where you went wrong... ugh copy and pasted wrong

Problem: POJ 3246 o! (convex hull + area)
Learned: 1) Don't need to implement 2) idk why but a seemingly
O(N^2) problem can pass this case when you just make the convex hull and try deleting all points
3) Other solution includes for all points inside ABC find the convex hull ... excluding C = and then solve
(that exclude case work) O(pN) too I think. really hard implementation
4) Implementation = memcpy (src, dest, sizeof(src)) can do N * sizeof(int) or N * sizef(Point)


