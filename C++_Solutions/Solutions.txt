General Tips:
1) Seize the day, You CAN DO IT! State Champion, A+ CS61B, USACO Platinum
2) Remember your falls - USAMO, HS
3) Do harder Problems - 1 C problem maximum, 2 D's for concept, 3 E's FOCUS ON E PROBLEMS
4) Read the question carefully 3 minutes practice
5) Write solution without paper -> good notes/scratch
(I feel like your scratch work sucks more intution)
(Scratch for examples + pseudocode + jotting down ideas only)
6) You must take breaks every 2 - 3 hours. 
7) Code carefully -> minimize debugging. 
8) Editorial + Read 2 other people's solution carefully with the intent to learn something new!
9) Not about perfection but direction... 9/10 test cases = good on first try 


Tackling hard problem:
1) Solve the 1-dimensional version of the problem first.
2) find base cases
3) do small case examples
4) Make observations... 

Solutions of Good + Hard Problems: * = redo, ! = hard/tricky, x = 50% understand, o = did not implement

Problem: CF812D x (nchtr euler's formula + tin??)
Origin: http://codeforces.com/contest/812/problem/D
Learned: 1) Solve harder problems 2) read, show work, and think to do more in problems
3) take breaks 4) read other people's solution with intent to learn 5) rooted tree simplification
6) recognize that only last person linked matters 7) euler's size dfs. 

Problem: POJ 1654 (Triangle formula idea easy, implementation a little tricky)
Origin: http://poj.org/problem?id=1654
Learned: 1) MLE makes sense because CHUCK ... you cannot have 20 million x 2 doubles...
2) Algorithm correct = cool triangle formula to split polygons into triangle and use cross product to solve
3) Store only the points you need. 4) POJ sucks 5) 15 minutes debugging maximum 6) It's okay I give up lol

Problem: POJ 2242 (circle formula 3 points easy)
Origin: poj.org/problem?id=2242
Learned: 1) Formulas for circle yay. 2) Computational geometry -- angle bisector.

Problem: POJ 2084 (big integer practice recursion easy)
Origin: http://blog.csdn.net/jasison/article/details/8753814
Learned: 1) Java Big Integer practice 2) Catalan numbers recurrence relation cool!
3) Nice Big Integer C++ implementation... 

Problem: POJ 2693 (hard implementation easy geometric idea)
Origin: http://www.cnblogs.com/william-cheung/p/3641553.html
Learned: 1) Got all the edge cases surprisingly. 2) 2 UNIQUE circles. 3) Find perpendicular bisector ... and then solve
4) account for edge case with the distance being = to 2.5 5) bisector to line count... :D 6) May be easier if you keep point and line short and sweet;


Problem: POJ 2085! (2 realizations about minimum permutation)
Origin: http://poj.org/problem?id=2085
Learned: 1) Implementation Problems / Ad hoc = solve first with examples 2) define clear algorithms and implementations + examples
3) code fast + code with examples... 4) win!!! 5) If you are stuck -> list sample cases at least 5 then -> try to find a pattern! 
6) One line cute solution of just finding the minimum n + k and reverting order...

Problem: POJ 2356! (tricky bijection realization)
Origin: http://poj.org/problem?id=2356
Learned: 1) Smart solution!!! uses bijection. 2) Do examples -> realize that sum can always take up 1, 2, 3, ... n -1, 0 mod n; 
3) If it repeats the sum then that means that the solution exists between the previous value of the sum and this value. Else they will continue to be unique until you get too n
4) Good read + examples (work on examples -> observation) 4) Think how can I find a cleaner solution.


Problem: POJ 1426 (got it first try!) (bfs)
Origin: http://poj.org/problem?id=1426
Learned: 1) BFS can even simplify to just use long long with math approximations...
2) BFS = use map to keep integers make key observation that all 10 = x 10 + 1 and x 10 = iterate through and solve!!!


Problem: POJ 1148 (IOI 2002) (alternating signs)
Origin: http://poj.org/problem?id=1148 
Solution: http://www.ioinformatics.org/locations/ioi02/contest/day1/utopia/utopia-handout.pdf
Learned: 1) 10000 = should involve sorting 2) 2D break down into 1D problem 3) Realize that 
you cannot brute force it so you must find a smart solution... 4) Pattern of alternating signs and how you can always maintain + or - 
5)  Really smart way of alternating signs to keep + and - so that you can find xc and solve. :D 6) coding = dx dy simplification, then use functions to solve repeated parts, x and y etc.

Problem: POJ 1905 (binary search + math practice)
Origin: http://poj.org/problem?id=1905
Learned: 1) Perfectly imperfect, focus on rest, focus on work, treat it like contest, focus on learning
2) Do math quick... you can do the math faster. 3) Your binarysearch on answer is correct. For doubles it is really simple just keep on dividing
4) asin0 r0 = part of circle 5) d = ... d < 0 wrong!!! just do x < y EPS matters in computational geometry. 6) to make more precise do < EPS 3 digits more specific than what they ask 
6) In contest just do 100 iterations or something like that.

Problem: POJ 2653 (queue + line segment practice)
Origin: http://poj.org/problem?id=2318
Learned: 1) Cool observation that there are only 1000 max results 2) Simplify's problem and use two vectors to insert and delete 
3) segment intersection borrow from stanford, or can also do two line intersection and check if the point lies on BOTH segments!!! :D
4) can also use a queue!!!

Problem: POJ 2318 (cross product + binary search)
Origin: http://poj.org/problem?id=2074
Learned: 1) In Box if cross product < 0 or clockwise if you go around the points in a polygon in a clockwise fashion for all the pairs of subsequent points O(mn) solution
2) can also use binary search to solve it faster in O(m log n) hi = n + 1 = always smaller, lo = 0 always bigger. 
3) Many ways to do test if a points is to the left or right of a line. best way = CCW or not. Or you can also do project point to line and compare x coordinates...
4) %lf coding be careful. Use binarysearch technique to debug...


Problem: POJ 1696 (cross product practice)
Origin: http://poj.org/problem?id=1696
Learned: 1) Use slow_hull idea to solve 2) q == -1, mindex, optimizations, keep on turning left. p, i, q. 
3) can also implement another way by having a sorting function and sorting every time by point. 

Problem: POJ 2074 (line segment intersection + sweep line / sorting)
Origin: http://poj.org/problem?id=2074
Learned: 1) Please read the problem 2) Please do the examples 3) Then try to solve the problem, else you are trying to solve an impossible problem... 
4) Practice not solving and feeling comfortable 5) right to left, left to right to make coordinates 6) then sort 7) then use max min loop to solve

Problem: POJ 2540 * (Intersecting half planes Implementation half way)
Origin: http://poj.org/problem?id=2540
Learned: 1) Implementation half way but good enough for now 2) Half Line intersectin problem
3) May be some bugs in my line_point_beta implementation... but good enough for now... 4) Got the general idea
that first we need to calculate perpendicular bisector of prev and next point. Then add this point to the lines.
5) Use CCW to determine if point is to the left or right of point, if so then switch the lines directions
6) Finally solve the intersection half points problem by doing O(n^3) to get points, then convex hull, then compute signed area.
7) don't do halfplane problems yet... 

Problem: POJ 1228 * (convex hull + collinear somehow messed up implementation whelp)
Origin: http://poj.org/problem?id=1228
Learned: 1) Treat it like a contest 45 min timer wow I did it so fast. Starting tmw. 
2) 11 sleep 3) I actually got the implementation details... use convex hull to mark the current polygon
4) Each line segment must have three points in it!!! :D 5) Slow way = first way = have old points and check if there are three points per pt = O(N^2)
5) fast way in O(N) = since your convex hull does not remove redundant you can check if three points are collinear in O(N) 
6) nice rotating calipers technique to simplify three point checking 7) if polygon or shape can loop around cirlce once or twice in a specific manner to simplify the problem :D.

Problem: POJ 1408 (line line intersection + implementation) 
Origin: http://poj.org/problem?id=1408
Learned: 1) Treat it like a contest 2) Trust in your functions 3) Solved it in 1 hour and 30 min
4) Could have simplified implementation and just done double for loop. 5) Pretty easy problem with just
line line intersection and area calculation! :D 

Problem: POJ 1584 ! (point in polygon, convex, project point to line + implementation)
Origin: http://poj.org/problem?id=1584
Learned: 1) Missed edge case of point being outside of peg. 2) Got the other two conditions that polygon has to be convex and 
point projected onto polygon has to be > than radius 3) Good consistent 2 hour, hard work, + no implementation = learning!!! 
4) Point projection easy, convex easy orientation, pt in convex polygon easy orientation, pt in nonconvex polygon a little harder = use stanford solution
5) *** note you are not given ordering of polygon (counterclockwise or clockwise)...  (tmp sign) 

Codeforces Round 419 Learned:
1) 11 - 6 AM consistent  
2) Work hard 2 hour sessions like contest
3) Work smart... people don't spend as much time but they do better because they don't train dumb
4) Problem = contest daily + learning not coding + 2 hour coding session 
5) Coding tips: read question twice, think (no writing), when solving right before you code you must spend 3 min checking if you missed any edge cases or can simplify code.
then, when you get WA reread question seeing if you missed anything (carefully), then -> go and resolve/recheck algorithm


Problem: Codeforces 419A
Origin: http://codeforces.com/contest/816/problem/A
Learned: 1) scanf("%d:%d") to read in input 2) increment counter until you get a valid palindrome 3) should solve in < 10 min

Problem: Codeforces 419B
Origin: http://codeforces.com/contest/816/problem/B
Learned: Got right idea, used set implementation which obfuscated the material. Could have
done a very simple implementation of using a[i]++, and c[i] = c[i-1] + (p[i]>=k);

Problem: Codeforces 419C
Origin: http://codeforces.com/blog/entry/52742
Learned: 1) Right implementation idea, use greedy to decrease until 0 then iterate and solve
2) Please be careful about implementation though... make sure to check edge case cause it's minimum # of row, column
(faster please)

Problem: Codeforces 419D *!o
Origin: http://codeforces.com/contest/815/problem/B
Learned: 1) Brute force method... print out all the values of n = 1, 2, 3,.. with the values 0, 0, 0, 1, 0, 0, 0
This can produce an easy brute force solution based on n mod 4. (last case 10 min brute force 10 min solve 10 min code) 
2) Cool method: 1) realize how easy addition easy -> contribution per item is (n-1) C (k-1). 2) Simplify task to all even 
such that it becomes + - + - + - with even number of tasks. Can just brute force this. 3) Even tasks can be solved by dividing it into
groups a1, a3, a5 etc... and a2, a4, a6... and it simplifies to the easy addition case.  4) wrote invfactorial method and factorial mod method


Problem: POJ 3525 !x
Learned: 1) HalfPoint intersection, can represent in counteclockwise manner as 2 points.
2) binary search while (r - l > eps) or for (; i < 100; i++) (me gusta second option)
3) HalfPlane intersection O(nlogn)  = clear pass = implement later or (O(n^3)) can also pass
4) Check if the halfplane intersection of the newly created polygon is 0 or not.
5) to create line you do double dx = (a.y - b.y)*p/len;
	double dy = (b.x - a.x) * p /len; x" = x + dx, y" = y + dy;  6) halfplane = two point representation...
	(use simple cases to deduce sign and this is because of perpendicular lines)
6) When implementing... be very careful... when debugging = first re read if you are wrong, then go step by step
and see where you went wrong... ugh copy and pasted wrong

Problem: POJ 3246 o! (convex hull + area)
Learned: 1) Don't need to implement 2) idk why but a seemingly
O(N^2) problem can pass this case when you just make the convex hull and try deleting all points
3) Other solution includes for all points inside ABC find the convex hull ... excluding C = and then solve
(that exclude case work) O(pN) too I think. really hard implementation
4) Implementation = memcpy (src, dest, sizeof(src)) can do N * sizeof(int) or N * sizef(Point)

CF Round 418
Learned: 1) More work on DP 2) Speed 40 min B ugh 3) D problems are so hard 4) more contests
5) Solutions are short (except for D)

Problem: Codeforces 418B
Learned: Got the right concept = try to recover permutation, where they differ by two spots.
Then after that just brute force the possibilities and see if it matches a and b.

Problem: Codeforces 418C (DP) *!
Learned: 1) My DP is very lol confined to just interval length DP, and 3d DP rip. 2) This 
problem has an easier DP which has the prefix max formula that each query = (r - l + 1 - t <= m)
2) Keep DP of ans[ch][moves] (this should be first thought) because it's intuitive. 
3) To get DP O(N^2 * 26) solution = iterate through every character. intuitive. 4) Your DP of interval somehow works
as your recurrence of transition states is correct... (just requires a lot of consideration of base case etc. which should be faster)
5) Simpler DP = use prefix max, replace_ct. DP from starting point and len. 6) Another simpler solution uses sliding window (from USACO hashing)
and keeps left and right min max. http://codeforces.com/contest/814/submission/27640540

Problem: Codeforces 418D (Geo + DP + Greedy) *
Learned: 1) This problem was actually really easy... could've solved :( 2) Go with the attitude that you can solve level D 
3) Simple observation that you just split two groups by biggest and second biggest (kind of like chess tactic) = then the answer just alternates
4) Greedy -> solve. 5) Observation of rooted trees and how one node is in another. 6) Also has cool DP solution that I don't fully understand yet. 

Problem: Sweep-Line Line Intersection (Sweep line)
Learned: 1) sort always make_pair() 2) O(nlogn) 3) Event = simplify use event wisely, segment(x1, x2), segment (x2, x1)

Problem: Union of Rectangle (Sweep line)
Learned: 1) long long vs double be careful 2) O(N^2) 3) Use boolean array to keep in set
4) sort by y and x... 5) tricky implementation but sweep first by x, then by y; inset... 6) data structure important
index to link elements together


Problem: PowerSupply (Topcoder sweep line) o
Origin: https://community.topcoder.com/stat?c=problem_statement&pm=5969
Learned: 1) small constraint = recalculate sweep line at each input no need for set
2) sweep from bottom to top! left to right, diagonal wise. 3) sort and then sweep. 4)
x and y = can maintain set and add points d and -d away or can also just calculate it with a for loop
5) diagonal = c[i] = x[i] + y[i]. c[i] = x[i]-y[i]; = distance away from sweep line. (geometric property why)


Problem: ConvexPolygons (Topcoder sweep line, Intersection of two rectangles) o
Origin: https://community.topcoder.com/stat?c=problem_statement&pm=4559&rd=7225
Solution: http://www.topcoder.com/tc?module=Static&d1=match_editorials&d2=srm250
Learned: 1) Solution 1: a) computational geometry = you can find intersection of all points in O(N^2)
b) find all the points in b and on a, find all the points in a and on b. 3) This is all the points in the intersection
4) find convex hull of all the points. (convex hull does not need sorted points remember!!!) 5) calculate area!!! 
Can do in 10 min! 
Solution 2: Use sweep line = O(N^2) calculate the intersection of the lines b. Sweep by x coordinate
and go one by one. Calculate intersection and sweep

Problem: WILD (Sweep Line + Segment Tree) ox! (I will implement later map!!!??? or segment tree)
http://www.spoj.com/problems/WILD/
Learned: 1) Combinatorics calculate inverse easier = envision union of 3D rectangles 
2) union of rectangles = line sweep by z 3) Can do m^2 - sum for every m = m iterations + n log m to update sum
4) Intuition - calculate opposite easier, then see 2d solution with sweep line -> 3D solution idea! 5) implementing 
with segment tree looks fun. Update interval ranges. 6) Implementing with map hard/tricky but cool. A) Add m+1, 0 as bounds
B) Then use maps lower bound function to evaluate ranges. C) Use map.erase to delete old ranges that no longer apply!!!
:D

Problem: CF 612D
Learned: Easy problem 1) Code slowly so you don't have to debug a) what you typed b) right before submission
2) Use pair<int, int> to represent simple events from now on. 3) Sweep line!

Problem: ACM Timus 1469 (Line intersection bentley ottoman) o? (If not satisfied with line sweep implement with set)
Learned: 1) Makes a lot of sense after you understand algorithm, add cur to set, left endpoint = upper lower delete from pq, upper cur connect into pq, lower cur connect into pq
3) Right endpoint = connect upper lower. delete cur from set;
4) intersection event = delete e from pq, swap positions in set, so E1 > E2. In pq, delete intersections... :D
5) Hard to code/data structure and no solutions = no code.
https://github.com/vadimkantorov/acm/blob/master/acm.timus.ru_33735/1469.cpp
6) Good use of data structures 7) Segment = Left, Right, Index :D bool operator to sort 
8) below and above helper function with sets = ++loc and  loc != window.begin() ? --loc : window.end();
9) Used iterator and line sweep + helper functions + hackerearth iteration to find intersection!!! 
10) insert vs erase! easy! pair<iter, bool> inserted returned when you use insert function! 

Problem: CodeChef Bishop (Hard implementation + line sweep problem) x
Learned: 1) Break this problem down into sub parts 2) Obs 1: solve first white square + dark square
3) Obs 2: First gen segments (x and then y) that are possible, then calculate intersection 4) To make life easier rotate the square by 45
and then you get a simpler rook problem which is intersection of segments
Coding: 1) not 100% sure how to transform diagonal to vertical 2) create b[r] and o[r]. 3) write overarching functions
to calculate each part, gen_segments, intersect... 4) Use swap trick to create vertical and horizontal segments with same lines;
5) to generate segments, you only need to sort b and then you can just see if other chess pieces lie in same column. 
6) If not it = boundary but if it is then its equal to the b[j].y; 7) intersection = use events to do line sweep. can use BIT

Problem: CF 166B (TLE :( CF Convex Hull) * (Classical idea of binary search + log n implementation of finding if a point is in a convex polygon)
Learned: 1) Right idea Convex Hull of all points should contain only A 2) Implementation tricky
does not involve erasing points because convex and nondegenerate = no erase, does not involve checking 
edge cases where points repeat because it doesn't 3) Does involve keeping points on same line so what you do is 
> 0 not <= 0 for deletion!!! So I was right... Passed 31 test cases like that! :D 4) Wrong because TLE = simplify data structures
and make bool cmp better 6) Also change PT and idx implementation 7) Another way to do it is to use binary search on whether or not each point in B is in A.
7) Cool implementation of binary search on whether or not points is in polygon in O(logn) in 166B4.cpp 
8) 1 code slowly and carefully 9) pretty good at CCW 10) log n approach binary search cool lo = 2, hi = n; lo = always good etc. 11) PTs always TLE because your CCW functions
takes forever to run and making 10000 * 20 points is costly ... 12) Use simple functions if you can ... pair<int, int> #define x first #define y second if you can 13) Final trap...
long long needed to multiply integers. 13) For classes easiest way to add an idx or angle is to just let it be there and don't change any functions :D

Problem: CF 64D (Convex Hull Dynamic version + Map + CCW) *ox!
Learned: 1) Work: Flow!!! Had fun debugging + writing code :D = chuck just work like this 2 hour spurts = solve as many problems as possible (just learn)
2) Convex Hull idea -> sort everything by centroid angle (or by first coordinate if you can). 3) That is how you create your set structure of angles which
you add/delete from... (similar to binary search approach where you cut everything by half-planes) 4) then use set upper bound to find upper bound and decrease iterator to find lower bound
5) use this to create inside function 6) insert function = check if inside (if so then return) else continue erasing upper and lower halfs until you get convex hull (CCW on point easy with example)
Nuances/Language learned:  1) pred, succ, or inc, dec helper functions!!! 2) just use set<Point>::iterator don't use auto when passing in functions 3) Your struct
will have problems when you insert into a set and you have the copy function Point (&point p) and you have a new variable like k. (Be very careful!!!) 4) Point In Segment function!!!
5) atan2(y/x) pleaseeee 6) centroid function

Problem: USACO Platinum Cow Curling  
Learned: 1) Wow this problem is exactly the same as CF 166B 2) Just do convex hull + o(logn) to see if point is in convex hull 3) Line sweep approach maybe? 
4) Three Points Collinear/Points on Line is important 5) edge case of all lines ahh 6) Got one!!! 7) practice implementing by yourself so you get better at debugging but contest = copy
8) problem was bool operator const 9) convex hull must remove duplicates >= 10) PointInPolygon must check collinear case 11) helper functions to solve!!! GJ!!! Got it!
12) Can also do line sweep approach by denoting the tl, tr, bl, br and solving it by iterating through the trapezoids in O(N+M)

Problem: SPOJ SPoints
Learned: 1) Exactly same idea as previous problem 2) Check if two groups of points can be separated by line 3) Half plane intersection!!!
4) My idea: Check collinear check if contains or itersects polygon. O(NlogN) 4) Simpler idea: contains = if a point is contained/on a line = there's no way!
Already wrote code for that in USACO Platinum Cow Curling (Checks if point is on or inside = no) 5) Check if intersect... for points
if size >= 2 check if intersect of two line segments ... O(N^2) for loop.

Problem: USACO December 2017 Lots of Triangles !xo (CCW geometry)
Learned: 1) Original 40 min = so close got that you only need to simplify by a factor of O(N) to O(N^3) 2) Got that you can precompute half planes. 3) Missed that half planes
should stop at end of line segments = would've got it so close 4) 2 tricks -- 1 because the edge case of point on dividing line is hard to deal with you just 
do all points betweenbelow +=2 except points on directly below line = +1 5) Next trick is everything to the left = + if line segment goes right = - 6) Final trick = check for between below 
i, j which solves for last edge case. 6) n C 3 = for (i, n) for (j, i) for (k, j)

Problem: USACO November 2013 (Silver) Crowded Cows (Sweep line)
Learned: 1) Got the right idea sweep line 2) Remember sweep line is sort for loop
then WHILE loop of iterating left and right sweeps or for loop involving lower bound 
3) Could not find nasty bug so had to rewrite everything 4) Mark Gordon good coding = 1 for loop
with two while statements keeping left and right = erase and find smart use of sets. 5) Code slowly and carefully
6) think of perfect solution before coding 7) be careful with set size... 0% chance of wasting 2 hours

Problem: CF 199C (Geometry)
Learned: 1) Geometry problems input output easy just solve for geometric solution 2) Trick that h % r * 2LL !!! :D dn't make long long mistake

Problem: CF 340B (Largest area of a quadrilateral)
Learned: 1) 300 -> O(N^3) 2) Simplify by O(N^4) -> O(N^2) * O(N) or O(N^3) * O(1) 3) Clean solution... O(N^2) 
use the idea of cross product min or max to get the minimum area and maximum area of bottom sides and subtract them to get maximum area involving line segment :D

Problem: CF 203D (Point projection in 3D)
Learned: 1) fmod = mod for doubles 2) vectors = don't change even if reflect 3) vector d = r * t solve everything

Problem: CF 600D (Circle Circle Area Intersection)
Learned: 1) Just cause you have a formula does not mean you have to use it #good to better
2) For this you don't even need to know the intersection points. 3) You can just use the law of cosines
to find the angle, multiply angle by two and solve for area...
3) Not the problem with the cross product, but problem with area of circle... not r theta = arc length but rather r^2 * theta / 2;
4) simpler solution with law of cosines 5) Code slowly but make sure you are right!!! :D Got it! Circle Circle Intersection!!! (Way too long though :()
6) Be careful of floating point error = long double may have to be used ... idk about precision...


Problem: CF 277B (Constructivist convex polygon given points)
Learned: 1) Chuck for n = 3 and m = 5, 6 impossible other than that all possible (I kinda got that too) 2) Constructivist = prove some cases are possible or impossible
3) How to construct solution... form inner polygon and outside polygon (using roots of unity idea). Or you can do another cool idea of using a convex function x^2 + 10^7 and concave function 
-x^2 - 10^7 :D  

Problem: CF 30C (DP + Geometry)
Learned: 1) Simple DP Solution expected values just add because they are independent 
2) Not a dfs memoization ugh 3) Just a simple DP like you sort by time and add up max for t1, then max for t2, then max for t3 etc... does that make sense?
tk = if (ti to tk possible) then f[i] + a[i].p

Problem: CF 33D (Vika and Segments Line Sweep)
Learned: 1) Basically a line sweep problem with intersections 2) To solve for intersections you can use a segment tree
3) Or you can use a map<int, vector<int> > to simplify all the forms of point intersections. 4) After that you can then apply your line sweep algorithm
using events to really simplify and solve the segments and line sweep problem. (Probably will take you 10 min to pseudocode 30 min to write code and 20 min to debug)

Problem: CF 33D (Circle and Graph Theory) !X 
Learned: 1) My solution I think it works -> let each point be linked to the smallest circle it is in. Create a circle of Infinite radius to make sure every point has a circle *** trick
2) Then it becomes a graph theory LCA problem which is easy 3) Preprocess how many circles are above a certain circle and if a circle is in the same circle etc. 4) Solve!!! 5) Also there is a bitset solution that I don't really understand 
4) When you learn LCA http://codeforces.com/contest/33/status/D/page/12?order=BY_CONSUMED_TIME_ASC implement this solution!!
5) bitset solution for every circle. Then, for every circle that is bigger and contains this point set this circle on this points bitset to true.
6) ^ = inclusion and exclusion principle, xor bitset and or yields the correct solution. 

CF Contest 420 
Learned: 1) Coding pretty fast 2) Then stopped/couldn't think for some reason 3) Goals: I suck I need to work harder, smarter, and more consistently #get four on the next test
PTL this contest didn't count. Seriously though, I need to find my mojo back :D and start getting stuff done!!! #work HARD!!! #grinddd

Problem: CF 420C (Stack)
Learned: 1) Sad that I couldn't solve this easy stack question 2) I was 100% right in my intuition just sort it and keep on pushing into stack... only problem was TLE 3) Shouldn't
have made it more complicated. 4) Simple solution instead of sorting just clear the entire vector ... ugh (okay got it!) 5) Level C problems = Silver/beginner Gold = PLEASE PLEASE PLEASE
do not obfuscate it just very clean solution with vector clearing instead of sorting 

Problem: CF 681E !x (Circle intersection)
Origin: http://codeforces.com/contest/681/status/E
Learned: 5 conditions (got all of them but idk how to implement) 1. circle contains center -> output 1 2) Circle has 0 or 1 intersection -> continue
3) circle is inside circle = asin(r/d), 4) circle has two intersections = law of cosines 5) be careful atan2 is -pi to pi and asin is -pi/2 to pi/2  
6) atan2 of y-y0/x-x0 to determine initial angle, 7) angle +- the resulting angle. 8) interesting idea of adding left and right angles 9) sort and then loop to solve. tricky implementation
l < i.first l = i.first if (l >= i.second) continue; l = i.second; ans += i.second - l; or you can do +1, -1, keep on adding count. 
7) when coding be hella careful of EPS and long long 

Problem: CF 50C (Convex Hull)
Origin: http://codeforces.com/problemset/problem/50/C
Learned: 1) Convex Hull + up left direction change 2) Actual solution is simpler convex hull + max(x, y) changes + 4 (I get this because you can form a circle with 360 degrees which can contain the convex hull 
3) weird solution of max(x + y, x-y, y-x, and -y - x) idk why this works + 4...

Problem: CF 358E (Largest area of triangle in a set of N points)
https://stackoverflow.com/questions/1621364/how-to-find-largest-triangle-in-convex-hull-aside-from-brute-force-search/1621913#1621913
1) Cool geometric idea/proof by contradiction that the area of the largest triangle. If you find that and you treat this triangle as the mid points (hint 4S)
then you get a triangle of area 4S that has all the points. The proof is that if any point is outside this big triangle, then you have a triangle that is bigger than area S
2) Thus, you can find this triangle and do x[a] + x[b] - x[c] etc. for midpoint. cool idea that using midpoints of little triangle you can find big triangle
3) Final cool idea, how to find biggest area of triangle of N points. You can actually do it O(NlogN) may involve idea of convex hull :D 
stackoverflow idea can do it in O(N) but too hard to code. Better implementation is http://codeforces.com/contest/682/status/E
5) similar idea for maximum diameter in a polygon find maximum etc. withbinary search 

Problem: CF 305D
Origin: http://codeforces.com/problemset/problem/305/D
Learned: 1) I have a fibonacci solution that is wrong 2) Uses weird idea of max, min and 2^cnt ? 3) Passed :D skipped

Problem: CF 403D
Origin: http://codeforces.com/problemset/problem/403/D
Learned: 1) tricky DP problem. 2) Use idea that the number has to be less than 50
3) alternate DP, DP first on the c1 + c2 .. ck = j. The answer to that is dp[i][j][k] i = number of ci j = value k = max x
for (int i = 0; i < 50; i++) #of elements for (int j = i* i +1/2; j <= 1000; j++) value it can be equal to for (int k = i; k <= 1000; k++)
f[i][j][k] = f[i][j][k-1];  if (j >= k) f[i][j][k] += f[i-1][j-k][k-1];
4) calculate combination! 5) For each len, we can extend it by n-k C k :D 6) Multiply it by factorial :D 

Problem: CF 711E !xo (Combinatorics + Number theory + Legendre's theorem)
Origin: http://codeforces.com/problemset/problem/711/E
Learned: 1) Wow this problem was super hard (but got it no coding though) 2) Use complementary counting to get gcd of A = 2^n - 1 2^n - 2 ... 2 ^n - (k-1) and B = (2^n (k-1)) 
3) We need to find the gcd of these two numbers, which is a power of 2!!! 4) We can use Legendre's theorem to find which number divides 2^n-1 ... 2^n - (k-1) 
because if it divides A, it divides 1 * 2 * 3 * ... k-1 (expand by binomial coefficients to prove) 5) Legendre's theorem says that Ep(n!) = (n - sum of digits of n in base p) / (p - 1 )
https://artofproblemsolving.com/wiki/index.php?title=Legendre%27s_Formula. Ep(n!) for p = 2 is n - #of bytes in n / 1 = n - builtinpopcount 
6) After that, we can easily find the denominator, and numerator's divisor. To find the numerator we can notice that the MOD is really small!!! 7) This means we can iterate through MOD
and see if it's equal to zero, if so then num = 0. Else then, we just multiply each value... 8) Interesting remark, instead of calculating 2^n through log exponentiation
we can use fermat's little theorem and note that a^p-1 = 1 mod p. so we can mod every n by (mod - 1) and then exponentiate which makes it really fast! Also, to calculate inverse mod p.
We can note that aa-1 = a^p-1 = 1 mod p, thus a^-1 = a^p-2, so using modular exponentiation, we can calculate the mod faster...

Problem: CF 325E (Mu idea + PIE)
Origin: http://codeforces.com/contest/585/problem/E
Learned: 1) Find the numebr of subsets with gcd = 1. 2) Use PIE, gcd = 1 = 2^n - gcd = 2 = 1 * 2^cnt(2), + 0 * 2 ^cnt(4) + 1 * 2^(cnt (6)). Idea of mu. 3) Then more mu to solve problem

Problem: CF 325C (Stern Brecot Tree)
Origin: http://codeforces.com/contest/222/problem/C
http://www.ams.org/samplings/feature-column/fcarc-stern-brocot
Learned: 1) Stern brecot tree solution, x , y x + y , 2x + y, 3x + y, etc. 3x + 2y, look at link for more info 
2) Stern Brecot tree = use two previous left and right to determine direction. Can use interval/bfs to determine result 
3) Can use cool gcd algorithm in Stern brecot trees to determine the amount of left and right, given an inital stern brecot value
4) Other cool facts, is p and q must have no common factors, aka perfectly simplified rationals appear only once, Also, the two subsequent values
have a cross product of 1, This is because there process of addition is similar to vector addition. 
5) Finally, gcd works in weird way by noting the first turns down. x > y. so it must be a left turn so first guy + 1 or + x the amount of size it's truly greater. 
6) Then keep on gcding until 1. :D

Problem: CF 222C (Sieve + Factorization)
Origin: http://codeforces.com/contest/222/problem/C
Learned: 1) 99% sure I can do sieve questions, sieve maxn = 10 million = huge hint 2) I can factorize all things in O(1) 3) Trick to this problem is you can keep it at 
n, m and just do the reduction inside the for loop, with res = 1; if (fb[divisor[j]]) fb[divisor[j]]--; factor will never be > 10^7
 
Problem: CF 546D (Sieve + Factors)
Origin: http://codeforces.com/contest/546/problem/D
Learned: 1) cin is super slow okay fine I'll use scanf from now on 2) original idea of counting factors is fine but it is a little bit slow it runs in O(nlognlogn) + O(n*10) (number of factors in n)
you should be able to do it in O(nlognlogn) 0.5 ms difference 3) divisors[i] = divisor[j/i] + 1; 

Problem: Project Euler #64 (Repeating fractions number theory)
Origin: http://www.mathblog.dk/project-euler-continued-fractions-odd-period/ 
Learned: 1) Do these types of problems by noticing the recurrence relationship/pattern/finding a pattern 2) square root can approximate by equation S = a^2 + r
3) Solve then, by using the recurrence relation, getting base, case and finding termination condition  
4) http://www.mathblog.dk/project-euler-continued-fractions-odd-period/ continued fraction on project euler. Learning
5) don't need to 100% understand math, just get that there's a recursive formula and it repeats

Problem: UVA 834 (Repeating fractions gcd)
Origin: https://uva.onlinejudge.org/external/8/834.pdf
Learned: 1) This solution was soo easy 2) I actually got it you just keep on gcding until you get 1 3) Thought of edge cases but already covered by data set if you implement algorithm correctly
A[count++] use swap function to make life easier. 

Problem: CF 7C and Light OJ 1077
Origin: http://codeforces.com/contest/7/status/C
Learned: 1) Diophantine equations can be transferred directly to line and coordinate problems, remember more complicated ones like Pell's equation
2) Simpler diophantine equations can be easily solved by using modular arithmetic. If gcd = 1 then they have infinite solutions, if gcd != 1 then you have to make sure c divides the gcd. or c % gcd == 0
3) Lattice problem = if straight line then dx or dy + 1, if point then 1, else it's the dy/(dy/gcd) + 1. (has something to do with gcd)
4) For the non-lattice problem, it has to do with finding Ax + By + C = 0; 5) You can do that by doing extended gcd do find gcd.  the ax + by = d;
5) since it's ax + by + c make sure to negate c to get the equation ax = -c mod b; the result is c/gcd * x and c / gcd * y;

Problem: Light OJ 1054 (Factorization, divisor sum, Base exponentiation)
Origin: http://www.lightoj.com/volume_showproblem.php?problem=1054
Learned: 1) reminded of cool counting principle that sum of factors is (1 + n + n^2 .. n^k) ( 1 + j + j^2 ... ) etc. for all factors
2) this allows the simple algorithm of first factorizing (can make factorizing faster by first calculating sieve and then only using primes; 
3) next you can stoer the factors in pairs, of factor and number, then multiply count/number of factor by m (for the squaring) and use base exponentiation
to calculate n^km + 1 % mod. 4) Final trick is you don't need extended gcd to calculate the result... what you can do is just 
do p-1, ^ mod - 2 % mod, to find the inverse!!! Remember this!!! :D good job

Problem: NFACTOR SPOJ (Factorization, sieve easy!)
Origin: http://www.spoj.com/problems/NFACTOR/
Learned: 15 minutes per problem, I knew how to do this one! 1) sieve to get the number of primes this number is divisible by
2) create array and use dp like approach to store each previous result and add each result to each other
3) if this number has a certain x divisors add it! 4) Preprocess results and cout << dp[n][a] - dp[n][b-1]!

Problem: Light OJ 1007 (Phi)
http://www.lightoj.com/volume_showproblem.php?problem=1007
Learned: Use idea of calculating phi, then do phi * phi, then use dp approach and sum all the phi, then preprocess and find answer!

Problem: Light OJ 1067 (Combinations)
http://www.lightoj.com/volume_usersubmissions.php
Learned: 1) My combination algorithm is correct 2) use lld for lightoj 3) Inverse is multiplicative
n C k = n! / k! (n-k)! which means you can do n! * modpod(k! * n-k!, mod-2), I understand why mod - 2 = inverse but now I get why you can multiply both = powerful

Problem: Light OJ 1028 (Sieve + Base)
http://www.lightoj.com/volume_showproblem.php?problem=1028
Learned: 1) Key word 10^12 = can use sieve to calculate 10^6 and get the 80000 primes, then for every number iterate and divide even though 10^12. if (x > 1) at the end then that means it is prime. = sum * 2;
2) base of number ends in 0 if the number divides that number perfectly so find all divisors of n. Thus, we have to calculate all the primes before hand and then iterate through!!! also, you have to do sum - 1 becuse base 1 does not exist!

Problem: CF 687B (Sieve + Cool Number theory lcm)
Origin: http://codeforces.com/blog/entry/45770
Learned: 1) basic idea is that to find n, you need to see if lcm is divisible by k. 2) How to prove this, well CRT can prove it but you can also prove it by stating that
the answer is no if you have two numbers x1, and x2 such that they have all the same modulo c1 c2 ... cn but they have different values modulo k. this means that x1 - x2 = 0 mod c1, c2, c3 .. cn 
but x1 - x2 != 0 mod k. x1 - x2 divides c1, c2, ... ck which means x1 - x2 divides the lcm (c1, c2, ... ck) but x1 - x2 does not divide k. However, if k divides lcm(c1, c2, ... cn) then 
x1 - x2 must divide k. sample is 2 * lcm... etc. 3) to implement this, we just do sieve and find the prime factor of each value. Since lcm is way to big. prime factorize each value and find the max prime factor. 
4) Then calculate if the numbers you are given have all the prime factors. 

Problem: CF 616E !xo (Hard idea of how to sum up modulo equations together)
Origin: http://codeforces.com/contest/616/status/E
Learned: 1) Modulo = n mod 1 + n mod 2 .. n mod m = summation of n - lower_bound(n/i) * i  = nm - summation lower_bound(n/i) * i;
2) You can split this into two halves, i <= sqrt(n) and i >= sqrt(n). for i <= sqrt(n) you can just run a for loop adn calculate the sum. 
for i >= sqrt(n). that means lower_bound(n/i) < sqrt(n). Then, you use idea that the interval of n/i lasts = i * (n/i - n/i+1) starting from i = 1 to sqrt(n)

Problem: CF 632D ! (Cool idea of brute force and harmonic sum)
Origin: http://codeforces.com/contest/632/status/D
Learned: 0) m is small so you can brute force 1) Idea that for all divisors like 2, 3, 4, etc. if they are a divisor of the lcm then the lcm has all of the values of 4 2) Thus, first cnt the number of values of each number 
3) Use backwards for loop (to avoid overcounting) m >= 1 to add all the divisors... 4) Does not go over TLE because m (1 + 1/2 + 1/3 + 1/4 + 1/5 ... 1/m)  < m(1 + 1/2 + 1/2 + 1/4 + 1/4 + 1/4 + 1/4 +... ) = m(1 + 1 + 1 + ... 1) < 30 m = 30 million
4) After that we just find the cnt[i] from 1-m with the maximum number of divisors... 5) to get which divisor we print out we just do if lcm % in[i] == 0 then print out i + 1

Problem: CF 27E ! (Brute force DP/dfs)
Origin: http://codeforces.com/contest/27/status/E
Learned: 1) Maximum is 10 number of primes. 2) You can use dfs to find the answer or dp 3) basically for every number you can find dp recurrence or you can do dfs on layer like which one u use, how much u use and when to terminate! :D 

Problem: CF 134B (Stern Brecot)
Origin: http://codeforces.com/contest/134/status/B
Learned: 1) Brute force all the possibilites. 2) Use gcd or stern brecot to find the answer...

Problem: CF 207A
Origin: http://codeforces.com/contest/356/problem/A
Learned: 1) Many segment tree problems can be solved with an efficient usage of set. 2) You can use set with erase and lower_bound function = very powerful.
3) For this problem you can also use a disjoint data structure which stores the value of next and current 4) Finally you can use segment tree update boolean counter 5) getnext();

Problem: CF 380C
Origin: http://codeforces.com/contest/380/problem/C
Learned: 1) Classic Segment tree problem 2) Tricky part is how to merge, other than that pretty straight forward

Problem: CF 61E *!x (Implement)
Origin: http://codeforces.com/contest/61/problem/E
Learned: 1) Basically for each ask in middle it asks for how many greater and how many less *** classical problem 
2) what you can do is sort and then for each element insert it into BIT tree. (at end). first you check sum(id(x))
which checks for how many elements on the left that are less than this, then, left greater =  id - leftless 
right less = i - sum(x). right greater = n - id + 1 - rightless. 
Use this then to calculate the multiplication. Other solutions really compact and weird implementation

Problem: CF 459E 
Origin: http://codeforces.com/contest/459/problem/D
Learned: 1) Similar idea of counting left and right equal and unequal element, 2) uses idea of a map. 

Problem: USACO Silver 2012 Running !x
Origin: http://usaco.org/current/data/sol_running.html
Learned: 1) creative thinking = good 2) Plan read problem light, then hard, then creative then hard then creative then hard 3) Have fun!!! I had a lot of fun solving this problem :D 4) Just live :D
5) creative -> hard :D hard = check if you missed any edge cases/ideas 6) Had completely right idea of building up results one by one and adding the total :D 7) Using bit tree to remove the prefix problems :D
8) Got the idea of BIT where you first sort and then add by mods. 9) tricky idea of implementing long long caused several bugs. 10) Then missed the whole idea of how the numbers are real and not mod C but mod C * s[n-1];
11) This makes me use the sliding window to sort everything accordingly!!! which was cool 12) GOT IT!!! :D

Problem: CF 474F !x
Origin: http://codeforces.com/contest/474/problem/F
Learned: 1) 10 problem rule, do 10 problems... don't need to do every problem 
2) Got segment trees!!! 3) Segment trees are really simple in idea actually lol keep two - three functions build, query, update 
(change combine and return functions to acomodate and store different objects) 4) Cool idea of gcd(a, gcd(b, c)) = gcd(gcd(a, b), c)
5) Because gcd is commutative we must find the least number and check if its the gcd of all the elements we are searching for. if they are equal then ret -= cnt of least element
6) add combine function to add results 7) coding = good code fast and then check once to make it compile and get right answer = submit!! while the test is running check again... :D for corner cases... 8) fix bugs 9) coding tip use ? 
10) idea completely right, weird idea where you can do gcd[i] = gcd(gcd[2*i], gcd[2*i+1]), and find the gcd of all the elements somehow... 

Problem: USACO Gold 2017 CircleCross
Origin: http://usaco.org/index.php?page=viewproblem2&cpid=719
Learned: 1) Wow I can do silver problems in 5 minutes now okay more like 15 but still 2) Yeah let's get good enough to be able to see a problem and solve it
3) BIT tree easy mp.count, n counter :D

Problem: Codeforces 292E (lazy/Segment)
Origin: http://codeforces.com/contest/292/problem/E
Learned: 1) Can solve with segment tree 2) use creative mode = super fast 3) switch range and query updates 4) use the idea of time in to update the query
5) other people can store the query and then they update it! :D smart!!! 6) getfa(solution) too somehow
6) a+i, really simple implementation use ? in seg tree to simplify, remember 1, 0, n-1, are yyour st and en and everything else may change, l, r = query range etc. blah blah

Problem: Codeforces 501D (Bit)
Origin: http://codeforces.com/contest/501/problem/D
Learned: 1) simple math concept/combinatorics of permutation 2) k * n-1! etc. 3) calculate using bit trees of what digit you are 4) calculate the mod according to their values
5) then reconstruct the values with a set. 6)https://en.wikipedia.org/wiki/Factorial_number_system

Problem: Codeforces 220E !xo (set, two pointers)
Origin: http://codeforces.com/contest/220/problem/E
Learned: 1) Hard problem going from just doing simple sum on ranges to actually using 2 ideas 2) Key idea
no more than k inversions 3) whenever it says no more than k on an array you should think of using two pointers
4) Two pointers = keep up to k and then add or delete points using segment tree 5) cool idea that adding inversions is O(n)
6) can turn it into o(nlogn) by adding inversions in logn with segment tree 7) add l - r + 1;

Problem: Codeforces 338E !xo (pseudocode, sorting, segment tree)
Origin: http://codeforces.com/contest/338/problem/E
Learned: 1) Hard problem 2) nice realization about sorting that you can find the answer in O(n) if its sorted 
3) key idea is setting everything to -1, 4) update tree with min idea to see if you ever reach a point where both sides have numbers which meet h
5) tree root >= 1; 6) sorted array lower bound to find index
7) find position in O(log n) 

Problem: Astar Placement test Work scheduling
Origin: N/A
Learned: 1) Union find is able to solve for ranges like finding the least element/scheduling problems 2) union find with map tricky count the -1 + 1 etc.
3) Review your algorithms 4) don't code unless you are able to be 100% sure 5) greedy solution :D 6) scheduling, sliding window, binary search...

Problem: Astar Placement Test Running
Origin: N/A
Learned: 1) DP really simple for some reason TLE

Problem: Astar Placement BFS
Origin: N/A 
Learned: 1) Dijstrka/bfs reimplement! 2) Yeah just dijstrka and keep the first k elements in dijstrka 3) BFS really smart + binary search ... 4) implementation = be careful graph[i][j] etc.
3) Binary search on answer 1 - 10^6 4) important, union find forward, binary search on answer, and pure algorithms, and lastly sliding window technique
6) return 0 does not work in outside. 7) be careful graph[u][i] etc, memset(m, -1, sizeof(array[0][0]) * w * h); memset(d, -1, blah); no INF; use for loop easier 

Astar Placement: 1) review Graph theory before contest 2) do problems with less writing but more thinking or drawing examples... (think this is easy) then type out pseudocode. 
(practice pseudocoding without pseudo) write out pseudocode 4) Don't get stuck on a problem #moveon 5) debugging tips = think of edge cases

Problem: Astar Lights Out (Bitmasks + DP)
Learned: 1) Assume minimum elements is K, we can always get K by just adding or deleting until the last K elements (key observation/have to prove). Regardless, we have to find the number of min ones to calculate DP
2) Use minimum # of element as subproblem 3) Use this, minimum # of elements as subproblem, calculate this. we can do it by finding the last k elements...  5) we use DP on state [i][j] all the states of the current bits
6) Hint is 2^7 so what you can do is keep only the last k bits... 7) Use problem parameters and question to get hints, you need minimum and you need to toggle lights and states = bits. keep min count of ones, why minimum?
8) with min zero then keep 3d dp of i, j, k...  
//dp[i][j]

Problem: November Bbreeds USACO Gold 
Origin: http://www.usaco.org/current/data/sol_bbreeds.html
Learned: 1) DP basics: state? recurrence? base case. focus on coming up with right state on hard dp problems
2) solve. 3) finding the right state may be hard. 4) recurrence...
5) recurrence is always +1, -1 though... 6) recurrence, add one minus one, A, B, i. f(a, b, i) = f(a+1, b, i) + f(a, b+1, i) for '(' open if closed then f(a, b, i) = f(a-1, b, i) + f(a, b-1, i) if a and b are > 0
6) simplify DP by reducing number of states. 7) memoize if easier top down 8) DP = O[b-a[i]] ... O = #of parentheses between a and b; #of parentehses = so good.  


Problem: USACO November 2013 Sight (USACO Plat)Line Sweep
Origin: http://www.usaco.org/index.php?page=viewproblem2&cpid=347
Learned: 1) Line sweep but radial sweep with clenches. 2) simplify by not keeping outside points but rather keeping points like the inside circle points
3) special cases by allowing circle to wrap around twice. = + 2*PI 4) priority queue solution clean = add + queue.size() 5) practice implementing solutions ugh! 6) set solution also should work ...
4) only problem today WTF do more problems 5) problem solve by not doing the dumb rotating calipers cause you miss a point ugh 6) need to project the points onto the circle and see which points are inside. 
7) can do it with a set or you can also do it with a priorityqueue by keeping track of two iterations... + 2PI for angle. only need angles... lesser than and greater than >= :D priority queue.push(); only people who end in the point are added.
8) understand 2 * PI and not being retarded 9) got the 2 * PI circle wrap around to make sure 10) got the set implementation where you just use 

Problem: USACO January 2015 CowRect (USACO Plat) Line sweep
Origin: http://www.usaco.org/current/data/sol_cowrect_gold.html
Learned: 1) better solution exists but O(n^2logn) / O(n^3) is fast enough 3) check each pair of points as horizontal vertices
4) key is that rectangle may contain more elongated points outside 5) sort points 6) sweep left for xleft, right for xright, and middle to see if it's valid... pretty easy implementation
7) involves line sweep with two pointers/check the points on the same line 7) two pointer idea pretty hard to implement actually ... left and right bad wrong.

Problem: USACO Silver Censoring (Practiced hashing wrote hashing template)
Origin: http://www.usaco.org/current/data/sol_censor_silver.html
Learned: hashing start with 0 index, indexing issues be careful

Pro Tip: Just learn algorithms for next three weeks in first half of class
Then second half = implement + problems + test out algorithm! :D

Problem: Codeforces 501D (BIT Tree)
Origin: http://codeforces.com/contest/501/problem/D
Learned: 1) bit tree + math can use for loop 2) index + 1 to avoid errors in ranges 3) use set efficiently to find key
4) debug error = fine but takes longer 5) use a bit tree to do last part too 6) to carry by one do the n-i+1 mod thing... :D

Problem: Marathon USACO Gold (Segment tree) !
Origin: http://www.usaco.org/current/data/sol_marathon_gold.html
Learned: 1) Got usaco segment tree :D 2) pretty good at segment tree tricky implementaiton 3) make sure you use combine well don't write helper functions... 4) delta function!
5) implement faster!!! but careful, safety = different every time

Problem: Lazy USACO Gold (Segment Tree) (Classical find maximum number of intersections of rectangle) !xo
Origin: http://usaco.org/index.php?page=viewproblem2&cpid=418
Learned: 1) sweep line problem + segment tree. Ahhh clasic sweep line with segment tree 2) I get how you must multiply everything by 2 to account for the case where you have to do +1, -1
3) I get the x-y, x+y to rotate a point by 45 degrees +1, -1, to reduce simplifications 4) confused why its not sqrt2/2 and why scaling does not change answer but whatever. (next time in rotation problems = scale like that)
5) sort by x-coordinates = sweep line 6) to reduce the number of points, sort by y coordinate :D 7) sweep line with lazy propagation got it classic problem. 7) query = number of points = lazy propagation 8) store end of i, and start of i to keep track of where you are. 
8) learn iterative segment tree when you get back (don't code it but learn it) 8) iteratively build segment tree with points = keep track of start and end y coordinates in leaf nodes, recursively build up all until 0 = min and max of y coordinates. 3) sweep line by querying each a and b
9) adding or substracting based on which element, cute lazy idea with fix(); exactly same as query_range, :D with fix.  
10) key takeaways: rotation, sort by x sweep line, how to solve these problems, and you can query not just by int but also by a[value]
11) Hard redo do not fully understand don't solve in problem, i get the transformation x -y, x+y, ? sqrt2 factor, understand the +1, -1, x2, get how line sweep, get how line sweep with indexes :D, get how to create a complete binary tree that stores segments, confused about mn and mx, 
confused on why 540000 confused on why firstB+i just solves everything???, finally understand how its 2*i+1, 2*i+2, and how you have to do ind-1 << 1 += to update, 1 indexed = easier, understand total+= alone[i] :D, yep!

Pain to not finish everything :D, pain to be happy, learned segment tree and how to solve it with sqrt(n) method keep chains, do it again, solve LCA normally, everything else = bit or graph algorithm + dfs, sparse table, rmq later :D, = 2000 cool -> 2300, rmq -> euler's tour, minimum values
11) rotation :D okay x-y, x+y, sort by x sweep line, solve by using binary tree index learn seg tree iterative better. 1) understand x+y, x-y 2) understand depth argument, depth >= number of nodes, ys.size() - 1 3) confused about min and max but whatever, default values... wrong, 4) then increment!!! :D 
5) increment endY[i] = startY[i] etc... 6) total[0]. inc(depth[a] etc) 7) ind-1 >> 1; 8) each leaf repersents ys[i] -> ys[i+1]


Problem: Gather
Origin: http://contest.usaco.org/TESTDATA/MAR10.gather.htm
Learned: 1) simple dfs implementation too long 2) just dfs to keep track of up and down 3) slide and update distance should be simple...
4) right formula just chuck you suck at implementing dfs ugh redo 5) chuck dfs = child[u] make sure graph[u][i] right when debugging first look at that!

Problem: Cow Caleisthenics (USACO Gold December) DFS + binary search !
Origin: http://contest.usaco.org/DEC10
Learned: 1) stack overflow MLE at 10000 be careful, idk implement with a stack??? 2) Be smart about it = recursive call can return, or I can store, store is easier 3)
binary search = life 10x easier 4) checking is easier than finding 5) greedy solution with checking if a graph is okay 6) dfs stack overflow 7) vector = o(nlognlogn) make sure to check if size is 0

Problem: Above the Median (USACO Gold November) BIT tree + prefix sums !
Origin: http://www.usaco.org/index.php?page=nov11problems
Learned: 1) Cute idea of partial sums coming up, 2) if BIT tree ever goes negative then what you do is + MAXN 3) I thought of it once I saw partial sums. 4) Idea of simplifying to +1, -1 
5) Basically counting the number of inversions such that i < j but P[i] > P[j]. I can count inversions now 5) basically update prefix sums all throughout. 6) 0 index = 0, 7) update it so that it counts all the prefix sums 
that are less than or equal to the current element. 8) always +1, -1 element.  9) > 0 for bit trees ugh, and also maxn + 5, update is +1, or -1. inclusive

Problem: Camelot (USACO Training Pages) Shortest Path 
Origin: https://usacosolutions.wordpress.com/2012/10/20/usaco-3-3-camelot-camelot-c/
Learned: 1) make sure to check the solution before you code ugh 2) Make sure algorithm is correct 3) make sure you account for negative factors or set it to infinite, errors = algorithm, long long double dist printf, initialization etc. 
4) cool idea of using 4d array to bfs, know bfs pretty well, best[i][j] wrong idea 5) neat idea of how the king only needs to travel +2, -2, because a knight can always travel to it faster...  like it can always bring it closer.  

Problem: Road Block (USACO Gold)
Origin: http://www.usaco.org/index.php?page=viewproblem2&cpid=398
Learned: 1) Meaning right, problem right, algorithm right, solution clear (slow and hased out), coding slow (add extra variables at first), debug slow (check initialization, variables, long long double etc), look at answer = algorithm 2) Make it like a contest = just do it
3) Make sure you know which type of algo to use 4) took too long 5) implement dijstrka using both ways! :D matrix = pretty easy to code, mindex idea make sure to set visited, 5) make sure to make graph = INF. 6) O(n^3) solution not O(mn^2)

Problem: USACO Relocate (Silver) shortest path + next permutation !
Origin: http://www.usaco.org/current/data/sol_relocate.html
Learned: 1) pretty good job of coding fast and keeping your calm 2) algorithm correct 3) take a step back and write correct answer
4) problem is that next_permutation changes digits so you should keep an order[i] which states the order of the current element without changing the original vector
5) also instead of set you can keep an is_market! 6) if tle with pq, try set erase or you can try another cool thing of putting an if statement to eliminate visited. jk no it's cause your algo sucks and there's a bug
6) nvm okay this solution is weird 7) implement dijstrka weirdly, if TLE then try implementing dijstrka using maxpq... weird but deleting stuff or using set. 

Problem: Longest Path (DAG Topological Sort)
Origin: Astar
Learned: 1) right algorithm 2) make sure idea is good 3) outline good 4) code well make sure you check why this code is write after writing a certain amount of code
5) if code does not look right do not look @solution = spend 10 minutes debugging by looking at code and checking what's wrong 6) Chuck please code careful (not autopilot) and debug (not autopilot) 8) algorithm right
9) be focused when coding 10) check errors.... :D in debugging

Problem: Cow Prom (USACO Silver)
Origin: Astar
Learned: 1) Weird interpretation of problem 2) wrote code to check how many sink vertexes in forest of scc with size > 1 3) code writing good :D

Problem:  Candy USACO silver (DAG + Topo +  Graph Construction)!
Origin: Astar
Learned: 1) Can use DP to solve this problem = knapsack 2) can also formulate this problem as a DAG 3) DAG have a topological ordering
4) wrote check cycle function!!! :D tests if there is a cycle 5) without a cycle = construct graph and then check longest path 6) hard part = edge case where the graph can go over!
7) also tricky edge case of how the graph can't go over on day 1

Problem: Euler's Tour Fences
Origin: https://usacosolutions.wordpress.com/2012/10/19/usaco-3-3-riding-the-fences-fence-c/
Learned: 1) euler's tour easy use set to check for duplicate 2) problem in code = algorithm not right 3) remember undirected condition only possible if all even or only 2 odd!!!
3) if 2 odd then u start on minimum of odd 4) becuase this problem allows just find the minimum every time and add it to the stack... use iterators!!! solve problem... 
8) I understand why you have to reverse the graph omg gg. 9) solve with cur_edge and solve with element. okay! 10) min element because you add it last. 11) ugh made bug in coding of typing begin instead of end()

Problem: TSP (USACO Gold) (DP + Bitmasks)
Origin: http://lms.starleague.us/mod/quiz/attempt.php?attempt=27769&page=4&scrollpos=0#q4 https://www.hackerearth.com/practice/notes/codemonk-dynamic-programming-ii-1/
Learned: 1) Do more DP + Bitmask problems :D and DP with more states + DP on trees 2) common mask ~ flip all bits, ! flip all bits, 1 << cur shift bits, ^ xor, mask & 1 << i == 0  bit i  not in mask
mask |= 1 << i add bit i to set, if directed graph, if undirected graph then mask ^ 1 << i; 3) typical pattern = base case = dp[1<<i][i] = 0; for int mask  = 0; mask < len; mask++ (this is because the previous masks build up the old mask)
5) for (int i = 0; i < n; i++) on inside!! or two denoting last vs cur... must have bitmask! interesting dp problem.  10) coding pretty good, understand it for cycles. basic idea down. 11) I can solve this problem idea good wrote template 12) bitmasks = udnerstand why the order is correct
13) bit mask from curent to last othermask = mask ^ 1 << cur  (mask & 1 << last) continue, understand, and use old_mask + curmask; 

Problem: BottleNeck (USACO Gold) (Greedy + UF)
Origin: http://contest.usaco.org/TESTDATA/JAN11.bottleneck.htm
Learned: 1) really hard problem it's okay I didn't get it 2) got the standard greedy solution of being able to find the answer in nk, 3) solving the real way involves using union find and some priority queue + union find data structure which like links each parent to its parent or something

Problem: Balloc (USACO Gold) (Greedy + Lazy Propagation)
Origin: http://lms.starleague.us/mod/quiz/attempt.php?attempt=27993&page=4#
Learned: 1) Greedy solution of sorting and choosing by end node 2) chuck I thought of sorting but ugh I only sort by beginning be more creative
3) after sorting it becomes a range update query question :D 4) nice observations!!! :D 5) implement lazy pretty fast!

Problem: Fence Repair (USACO Gold) (Greedy + Huffman Encoding)
Origin: http://contest.usaco.org/NOV06.htm
Learned: 1) maps directly to huffman encoding problem 2) cute greedy solution of huffman encoding of using priority queue memorize problem 3) proof of why huffman encoding is optimal is hard
4) pq 5) learn that choose one x 1 choose 2 = x2;

Problem: Corral (USACO Gold)
Origin: February 2010 contest
Learned 1) Use greedy observations that paths with smaller length cannot work, 2) use observation that you can find the next path and then create a component cycle
3) check all cycles in O(n) 4) use trick that double edges in a circle to iterate twice. 5) kill edges to eliminate repeat 6) after getting cycle just iterate through cycle nad check length. 

Problem: RunAway (USACO Platinum) Tree, Segment Tree, Pointers, Sparse Table  !xo (must redo)
Origin: http://www.usaco.org/index.php?page=dec12problems
Learned: 1) took wayyy too long for this problem 2) really good ideas in this #3 hard problem 3) redo this problem again with first pointers if you have time then seg tree
3) idea is like this create sparse table and go up 2^i. mark the first node that is too far from a vertex, then to count the # use all the childrens number - the counts that its' given
4) harder ideas include using a pq and merging the pq's of children together and 5) using a segment tree to update intervals after inorder dfs
6) Trees = always use children to build upon ancestor. 7) DP this way, greedy this way, but most importantly combine this way 8) new ideas of pq Nlogn^2, segment tree + inorder labeling by labeling start and finish
DFS traversal can find depth etc, segment and bits to update ranges, events to update new events, and finally using sparse table and counting from reverse side!!!
7) Okay 8/10 but got general idea, probably some index out of bounds sh2t, ugh good enough for now, try new update_range, and pq solution when you redo everything!!! :D

Problem: Slowdown (USACO Platinum) Tree, BIT, Segment Tree !xo
Origin: http://contest.usaco.org/TESTDATA/FEB10.slowdown.htm
Learned: 1) use labeling dfs to update tree!!! :D then use range query to update or find tree. 
3) Or you can use BIT tree in a very cool way. 4) cool idea of updating seen and not seen using bit updates to add the levels of what you ahve seen and haven't
5) then decrease the seen and not seen. sum!!! 5) really understand idea of labelling and given tin and tout 6) only did bit tree redo with range query updates.

Problem: Lost Cows (USACO Gold) ! precomputation + Bfs
Origin: February 2011 Platinum
Learned: 1) made observation that you have to go down 2) did not make observation that you can precomputate the n^2 edges so that you can go down in O(n^m)
3) after that it's just a really hard bfs implementation which you have to be careful about! 4) watch out what your vertices and edges are. goal is to get two cows to meet

Problem: Lost Few Coins (USACO GOld) !xo 
Origin: http://contest.usaco.org/TESTDATA/DEC06.fewcoins.htm
Learned: 1) One skip that I have 2) Really hard problem 3) Some how you can prove that the upper_bound is V^2 with math and modulos 4) I get the O((T+ V^2)NC) solution where you can just
use the standard dp and set dp[i][k] = min(dp[i-k*v][k-1] + k) for all k = 0-C 5) cute way of using another dp relation to minimize cost!!! Hard lol

Problem: Two Five !xo (USACO Training Pages Section 5)
Origin: http://www.cnblogs.com/txhwind/archive/2012/08/18/2645339.html
Learned: 1) Don't spend too much time on it! it's okay if you np for right now. come back to this problem 2) Get how 5^9 passes 3) cute recurrence that I got which is you can only go from one edge to the other when there is a perpendicular corner
4) Basically can solve this problem if you write a function that computates the value of a certain string like how many of that certain string there is. 4) use dfs to write the equation only tricky part is adding a t[i] to store the current value;
5) base case is when moves = 25 then you return 1 6) use memoization to store values, set transitions = dfs(a+1, ) etc. dfs(..B+1, ); starting from 0,0,0,0,0


Problem: Palindrome Path (USACO Gold Open contest) !xo
Origin: http://www.usaco.org/current/data/sol_palpath_gold.html
Learned: 1) DP really cute solution 2) redo this DP problem 3) DP problem = realize that use the length of the palindrome... and then add it. 
5) f(length a, row i, row j) = f(length a+1, row i-1, row j), f(length a+1, row i, j+1), f(length a+1, row i-1, j+1), f(length a+1, row i, row j);
6) use next and dp[cur] etc. 7) 500 x 500 x 500 = 125000000 which is actually fast enough for USACO servers so itll be fine! 8) Chuck I don't understand parts of the DP still Like I get the long long and the recurrence relation and how to get new indexes but I don't understand the stupid problem
8) ? got the transition states and etc. don't understand why you can add the old values that are not related and don't understand why it's dp[0][n-1]?
9) Understood the transition states like going from cur from dp, dp[0][n-1] because rowa = 0 and rowb = n-1, and finally going from dp[i][j] :D :D and lastly, it counts stuff from other length because all else = 0, beautiful thing about memsetting to 0!!! :D

Problem: Mowing the Lawn (USACO Gold Open contest) !
Origin: http://contest.usaco.org/TESTDATA/OPEN11.mowlawn.htm
Learned: 1) in these types of problem prefix sums usually comes up 2) find the dp relation, after dp you can realize that O(n^2) is too big so optimize
3) simplify dp by rewriting it in another format **** = can eliminate a variable instead!!! weee :D 4) with this recurrence simplification you can solve the problem in O(nlogn)
5) psums used in simplification 6) also to be fair :D using left to right pointer = you can also do something cool called using pq as two pointer instead of using set. or array
7) you can use pq, because only top value matters not ordering, 8) first value that you push is important because k can be one so watch out for edge case :D 8) BE HAPPY 9) next 3 problems = all seen before
10) code it like the real contest = 2 problems tmw morning = do more not less. 

Problem: No Change (USACO PLATINUM) !xo (Bit set, dp, partial sums, binary search)
Origin: http://www.usaco.org/current/data/sol_nochange.html
Learned: 1) 16 = bitset 10 - 20 = bitset!!! bitmask dp !!!! 2) most bitmask solution = O(k2^klogn, n, or k again) 3) use partial sums to compute binary search faster
4) use upper_bound() - 1 to get value >= element! wow not bad!!! :D 4) implement it with bitset mask values ^ = remove from subset & = whether or not in subset. 5) partial sums to do binary search
6) basically solution is we want to maximize value of left over subset so we want to minimize the value of the bitset :D left over thus, what we do is calculate for each 2^16 subset we can check how far this subset can go.
any subset that can cover than maximum it's complement can be a value. dp[k] stores the index of the last value that the array can cover. transition states is from any smaller subset that differs from current subset by 1. use binary search on that to calculate max value!

Problem: Telewire (USACO Platinum) !xo (Sweep line, DP, math, two pointer)
Origin: http://train.usaco.org/TESTDATA/NOV07.telewire.htm
Learned: 1) Got the DP O(NK^2) 2) tried to use segment tree lol which actually works here 3) Chuck ummm this problem has an easier way to update, which is after you find the dp relation
you can sweep through each value and find the low[n-1][h] uses clever math manipulation 4) then dp and solve. :D 
5) key here is isolating the h value so you can sweep line 6) sweep bottom and lower halfs!!! 7) really learn prefix sums well Chuck 8_ <?= :D huge lol 9) partial sums always used

Problem: Triangles (USACO Silver) !
Origin: http://contest.usaco.org/TESTDATA/FEB11.tri.htm
Learned: 1) O(n^5) = triangles 2) 3 things determine a triangle, starting point, length, and orientation 3) This makes the problem solvable in O(n^5) use partial sums + keeping old values to solve it in O(n^3)
6) really cute observation that you can solve it in O(n^2K) because a triangle can be split into four points so you only need length > 2 *k; etc. 6) implementation took too long because I wasn't focused
7) Good part is got it! 8) bugs in initalization can be negative in ans need -INF, long long watch out 9) iterate down ward and upward with partial sum 10) indexing was good chuck! use base cases and write out left and right :D
8) dumb mistakes = coding too long 9) understand it better now!!! 10) spend the time you need per problem 1 - 2 hours! :D 11) Chuck I think you should do it in four stages. one do the problem 30 minutes :D read the solution 30 minutes - 45 minutes w/out code reimplement 30 minutes w/code edit 15 minutes same plan do in morning = contest
10) afternoon = review make mistakes = learn + review in car 11) and then @ night = really deep learn = redo and rewrite the solution w/out looking @it. 12) coding = clean af gj chuck
12) no half-way doing it = no use.


Problem: Route Designing (USACO Gold) !
Origin: http://www.usaco.org/current/data/sol_route.html
Learned: 1) Looking at constraints + problem description should tell you which type of problem the problem is and how to solve the problem 2) O(100,000) = probably involves some sorting segment tree of parity or dfs etc. 
3) key idea is that the recurrence relation is that from x to y you need to travel from an A or B that is greater than x or y so you need to traverse all of them before hadn. However O(N^3) is too much to bear. so... you only need 2R routes!
4) we can process it in order by sorting. Then, assume we have calculated all the points below it. we can calculate the next point then. By iterating upward, in this manner we can say we've processed the solution bc it's A + B;
5) Dp relation -> process it by sorting -> find a way that iteratively calculaetes next value, solve small cases first 1 :D 2 etc. = recursion. 11) note never use left and right. 

Problem: Hop (USACO Gold) !x
Origin: http://contest.usaco.org/TESTDATA/OPEN10.hop.htm
Learned: 1) 3 hours > 1 hour of review hatred -> studying 2) Learned the idea of connecting the points together 3) found the idea that you can unite them and use partial sums to calculate 4) missed design in my reverse implementation where you did not account for partial sums that are greater 
5) Hop! :D 6) redo for 1 hour 7) got the general idea :D 8) flowing 9) 1 hour review 10) you have to watch out for n-2, and that you can turn back whenever, and when you push your queue, otherwise dp simple and then has O(NK) solution but partial sums/pq to implement. 8) use partial sums and set v as 0 9) coding without too much thinking
9) GOT IT WRITE!!!! 10) Fast pseudocode = good 11) watch out for initializations!! and empty cases 12) good idea how the psums is all that matter so you can keep it as 0 after that just try to min the dp and also edge case in O(n) of return_here - the negative v[i-1]. could make code better by pushing in a positive value but whatever;

Problem: Guard Mark (USACO Platinum) ! Bit Mask DP
Origin: http://www.usaco.org/index.php?page=dec14results
Learned: 1) Standard Bitmask DP problem, key was there is < 20 so < 20 = n2^n solution. 2) implementation problem = 1 << n - 1 and initialize outside the for loop with maxn 
3) pretty good @ bit mask DP now. :D 4) basically use the induction hypothesis to prove that the DP is optimal 5) DP is optimal if you use recursion. and then remove a certain number in the subset. continue escapes next for loop 6) built_in_popcount

Problem: Cow Decathlon (USACO Platinum) ! BitMask DP
Origin: http://www.usaco.org/index.php?page=feb14problems
Learned: 1) Bitmask DP again, p good @ it, implement total time = 50 minutes. Faster hopefully in future too! 2) Chuck coding very clean without debugging better :D practice/effort = good 3) Chuck key word is 20, 
4) then the bonus just sort and gredily add it!

Problem: The Baric Bovine (USACO Gold) !xo Classical DP with precomputation
Origin: http://www.it610.com/article/5361106.htm
Learned: 1) can solve with memo too 2) Classical DP problem with edge cases 3) precomputate the value of one like if you have two endpoints
4) then use dp[i][len] = dp[i-k][len-1] + dp[i-k][i]. basically block cutting problem where you remove one block!

Problem: Fencing (USACO Gold 2008) 
Origin: N/A
Learned: 1) Use convex hull iteratively with dp, 2) can find O(n^4) solution by setting bottom point and then finding conve hull of n points to the left of it by keeping track of tw ostates
5) more complicated solutions later 6) okay to just have idea. 

Problem: Visting Cows (USACO Gold)
Origin: N/A
Learned: 1) dp on trees use children and grandchildren keep multiple DP's 2) :D learned it before so super easy 3) do contest like this, remember don't forget max() the children!

Problem: Code Breaking
Origin: N/A
Learned: 1) I quit 2) this problems impossible lol so nawww 3) It's okay scott wu didn'tget it hahaha 4) somehow DP On trees with digits??

Problem: Btree !xo (USACO Platinum) Tree DP
Origin: http://www.usaco.org/current/data/sol_btree.html
Learned: lol

Problem: Buying Feed (USACO Gold 2011) DP With PQ/DQ/Optimization
Origin: http://contest.usaco.org/TESTDATA/NOV10.feed.htm
Learned: 1) In flow when you are working #do the work #read the problem, understand it, think of runtime 2) think of choose one don't choose one and transition states 3) solve the DP with base case and prove with induction
4) optimize the dp with pq/dq. 5) remove a varaible to make equation linear 6) solved pretty fast but code so slow because be careful of what your variables are 7) coding was bad #endgame debug ugh 8) code faster though but more focused
9) good watching out for initializations and empty 10) good job proving the upper and lower bounds 11) learned also how to do it with a dq with indexing where you just pop the elements that are bigger in front and add the elements that are the least in the back! (two instead of one while loop) optimize runtime!

Problem: Moovie Moving (USACO Platinum 2015 January) DP With Bitset
Origin: http://www.usaco.org/current/data/sol_movie_gold.html
Learned: 1) Implementation 50 minutes = pretty fast and good :D 2) but thought about it before, can be faster! 3) Chuck overall good job little coding errors 4) fundamental understanding of what dp represents = good
5) set notation cool 6) got bitset down later get all the other dp down = good! :D

Problem: Tower of Hay (USACO Open 2009) DP Hard
Origin: N/A
Learned: 1) Easy O(N^3) solution not really.... somehow the O(n^3) solution is that only the last layer building from reverse order matters 2) because of that you can process it in O(n^2) by fixing i your last element, then increase from i-1 ... what??? 3) somehow can transform into finding the minimum width
4) finding minimum width = O(nlogn) binary search solution with some random monotonic proof what??? 4) queue to solve lol fk this problem

Problem: Hopscotch USACO Gold (February 2015) !xo (Bit Tree + DP) Redo definitely
Origin: http://www.usaco.org/index.php?page=feb15results
Learned: 1) First figure out DP on this graph = you can transition from any of previous rows, to the current row, column = sum of all of them = O(R^2C^2) 2) use prefix sums to simplify to O(R^2C) = good solution 3) complementary counting = count all of the results in O(RC) using prefix sums but use map to count each individual element = TLE
3) Use BIT trees to update the elements in order, but be careful on how you traverse the BIT Tree!!! :D Tricky DP + precomputation + BIT
4) you can also just use partial sums to calculate it faster... 4) great problem from dp -> prefix sums -> bit tree simplification 5) work on opening (recognizing algorithm), using algorithms together, and finally implementing this problem effectively until you are done! :D redo!!!

Problem: Cbarn USACO Gold  (February 2016)
Origin: http://www.usaco.org/index.php?page=feb16results
Learned: 1) Make sure your dp is correct before you dp lol, dp should not be based off of previous elements 2) trick of circle
3) know that you can use DP better and implement faster, keep track of last visited digit (DP/implementation pretty good) 4) harder version = platinum = divide and conquer/monotonic structure

Contest CF 425 
Learned: 1) I choose to be happy, happiness in contest matters 2) problem - decreasing 3, 2, 1 1450????? Chuck ????
3) I need to do a contest everyday no matter what 4) Work hard and consistent when you get back 5) Chuck!!!! 6) doing the algorithm helps a lot! (50% opening + middlegame practice)
6) first mistake - read the question slowly = 3 times (no more reading mistakes) 7) stop thinking about speed, work with speed #no looking on time 8) flow and think about edge cases
8) consider all edge cases 9) code fast but accurate. 

Problem: CF 425D
Origin: http://codeforces.com/contest/832/problem/D
Learned: 