
General Debugging Tips:
If you get stuck skip to next problem give yourself at least 1 and a half hours per problem.
If you get stuck try a different solution. (worst cases)
If your code does not work/ X per test cases...try to debug it by running through code 3 times and 
checking where code went wrong.

REREAD PROBLEM. THINK ABOUT EDGE CASES!!!! LOOK FOR SIMPLIFICATIONS/CODE ERRORS

Algorithmic Study:
1. Operation-you need to understand how the code works
2. Runtime-how long it will take to run
3. Mutation-what parts of the code can be changed and what effect any changes will have on the algorithm.

General Solving Pattern:
THERE IS NO SUCH THING AS FAST CODING. CODE CAREFULLY. CORRECT FIRST TIME > TRY AGAIN OVER AND OVER. Do a lot of testing... and CF problems
Read one by one: You must first read problem slowly. (5 minutes) 
Design algorithm slowly but carefully. Go fast and slow. Problem Type, RunTime, Algorithm, Implementation, Tricks (25 minutes)
Make sure algorithm runs in time AND is codable in 15 minutes. (15 minutes code) (fast code but slow). 
How can I write the least amount of code in 15 minutes. Always make sure the solution runs in time < 10^8 preferably 10^7
Keep it simple!!! You must know how to code it!!!

Thinking of Solution:
1.Bottom up programming technique... split the problem into parts which you can solve. WRITE FUNCTIONS!!!!! (look at states)
2. Try to use known algorithms when you can!!! Categorize/pattern mine into algorithms.
3. Tilt the domain... transform input so everything is easier... 
circle -> linear... fraction to struct of int, mod ... slanted graph to straight graph...
4. Use invisible cues of problems... problem is doable to find solution...
5. Make sure to get the right approach.


USACO GOLD:
General Time Break Down:
Finish in 3 hours. 45 45 1 hour 30 minutes.

Ad HOC: Start from back/reorder/shift by one = common pattern/trick. Also don't forget prefix sums. Use vector then sets as last option...


Note: Array size < 10 million vector < 1 million 2d < 100,000
DP: = Simple, Try memoization if you cannot figure out DP after 15 minutes. what does i, j represent... write it down.
Top Down: Memo
Bottom Up: DP
3 Patterns, Typical dp, dp[i][k] = dp[i-1][k-1] + dp[i-1][k].  Interval dp, dp[i][k] (i = length, k = last position) = sum of (dp[i-1][j] + f(j, k))
Memo...

Common: LIS
for (i = 1; i < n; i++ )
        for (j = 0; j < i; j++ ) 
            if ( arr[i] > arr[j] && lis[i] < lis[j] + 1)
                lis[i] = lis[j] + 1;

GRAPH = Simple, ... often has DP and storing/memoizing results in it. Also remember XtoY simplification

BFS-> too slow usually, 
Dijstrka Queue -> O(E log V),
Kruskal O(E log V) or O(E log E sort)  Prim O(V^2)
DP keep it simple :D, mem < 10 million;
String: Think of hashing lol. 
Ad Hoc: brute force vs smart...

