* means redo

DATA STRUCTURE REPRESENTATIONS:
Graph: may have 4 coordinates surrounding, map<int, map<int, int> >, graph...
Fractions: Represent as val, mod in class
Circle: Turn into line... May need to rotate the graph...
Graph: each vertex can be DP on. reverse the graph? for shortest path of bidirectional directions

Problem: Castle
Origin: Week 6 Basic Graphs (Stanford) (Also from USACO Training Gate)
Learned: DFS, Floodfill, Java, Debugging use IntelliJ (look at where you think your code went wrong)
static variables declared outside, static class static method, Use dc, dr, array initialization etc.
copy all files onto USB, use buffered reader and writer always, no in.close, POJ = Main, USACO = class name
public class castle, adjust to the specific classes InputStream or FileWriter, copy classes to other parts!
http://poj.org/problem?id=1164

Problem: Knights
Origin: (From POJ 2488) (Stanford Lessons  Week 6 Basic Graphs #4
Learned: DFS, Floodfill, Java, Java Debugging Tool A+, (1 hour DFS :D), Compile Error Logs can see on POJ
Make sure to put all ArrayList<String> for good practice, don't forget base and initialization cases (work more carefully)
Also, can simplify code by creating a path of x and y instead of using arraylist, also can simplify toString function by doing
int a - 1 + 'A'; Use 2 arrays to keep track of path.
http://poj.org/problem?id=2488

Problem: Lasers (From Nick Wu)
Origin: USACO Gold 2016
Learned: @Override hashcode @Override equals HashMap, ArrayList, etc.
BFS: identify problem by same transition states, create the graph, bfs.
DFS: identify problme by small input size, create graph and iteration method, dfs/floodfill
HashMap uses .equals and .hashcode to find equal elements (must implement)
must rewrite .equals and .hashcode
If you are sure your algorithm is correct then it is often a small bug that is preventing your program from working
http://www.usaco.org/index.php?page=viewproblem2&cpid=671

Problem: Palindrome * (From Lewin Gan)
Origin: Berkeley Programming Contest 2014 Problem 2
Learned: DP 4 variables. Find all palindromes from one range to the other. Do so by using dfs and dp
https://github.com/lewin/Berkeley-Programming-Contest/blob/master/src/y2014/f2014-contest.pdf

Problem: Maxcross
Origin: USACO Silver
Learned: I can do these problems in less than 25 minutes now!!! Prefix Sums
http://usaco.org/index.php?page=viewproblem2&cpid=715

Problem: Perimeter
Origin: USACO February 2013 Gold
Learned: Use Map<int, map<int, int> > stl to solve, can use unordered map to reduce logN factor.
IMPORTANT: DFS problem = please!!!! 1. construct right graph 2. figure out whether or not you are using x, y
or r, c! 3. write the right recursive simulation 4. use do while loop if you need...
Another solution is to floodfill right outside...
Perimeter questions = dfs, bfs on inside, outside, on the edges
http://usaco.org/index.php?page=feb13problems

Problem: Tractor
Origin: USACO Feburary 2013 Gold
Learned: Union Find, can also introduce add size, size[find(x)]+=size[find(y)] [3], use comparator, use int[]
Can also do binarysearch and dfs floodfill together.. note in floodfill you can choose not to undo the floodfill
http://usaco.org/index.php?page=viewproblem2&cpid=245

Problem: SCC (on hackerearth)
Origin: https://www.hackerearth.com/practice/algorithms/graphs/strongly-connected-components/tutorial/
Learned: 1. Focus Chuck when you are solving the problem only focus on solving the problem... (everything else is secondary) #freedom
2. Add Watches to debug nice! use f7 f8 f9 ... step into step over step to next break point
3. ArrayList must declare all as List<List<Integer>> in compiler... in the runtime you can must set it equal
to ArrayList<Integer> ... also need to add new ArrayList<>
4. do not use arraylist.clear(); if you do you must make sure it's not pointing to the same object that other ones use...
5. learned kosaraju...
6. In submitting make sure to comment out the packages and the bufferedreader use the right one...

Problem: Euler's Path
Origin: None
Learned: 1. Euler's path conditions for directed and undirected graphs are different... //use for loop to find the starting points for paths vs cycles
2. Review for the next week everyday fifteen minutes...
3. Undirected = dfs, with dfs(g, res, u, curEdge). res.add(u) dfs(g, res, g[u].get(curEdge[u]++), curEdge);
4. Directed = dfs with hashset to ensure you can't use same point
5. List<Integer>[] g = new List[n+1]; syntax... syntax for ((Long) Math.min(u, v) << 32) + Math.max(u,v); << if you want u, v to be covered.
6. u, v = coding conventions, names like stack, queue, curEdges is good.

Problem: Reduction Paths (POJ 3177 Problem 6 Stanford Week 4 Graph Lessons)
Origin: http://poj.org/problem?id=3177
Learned: Biconnected components solution... or you can do tarjan solution...
1. you can do 5000 x 5000
2. biconnected and tarjan are very similar... difference?
3. use the p, j solution from google site
4. you can look at people's solutions and understand them... missed edge case... not bi connected problem but finding bridges problem
5. you can use adjacency list to solve the question...
6. split into connected components and see how many connected components connect to more than 1 connected component...

Problem: Power Hungry Cows (POJ 1945 Problem 7 Week 4)
Origin: http://poj.org/problem?id=1945
Learned: Implement Q with arrays... The order in which you choose to add is important...
You can simplify add not count all the possibilities that don't help you arrive at your result...
memory limit... you don't have to add all of them because you only need to get to one x, y

Problem: POJ 3275 Ranking the Cows (Problem 8 Week 4)
Origin: http://poj.org/problem?id=3275
Learned: https://github.com/lemonwu/icpc/tree/master/poj/problem%20from%20stanford/Basic%20Graph%20Algorithms
1. Simple dfs to solve the problem lol 2. In games with choosing least ordering think what is the maximum number of total combinations possible
3. key observation that all unvisited points must be considered so dfs or bfs to visit all points already compared and subtract from maximum
4. Lemma that this is correct answer?

Problem: POJ 2337 (Problem 10 Week 4)
Origin: http://poj.org/problem?id=2337
Learned: I actually got the right implementation in theory lol
1. Ask yourself in graph questions, what are the edges and nodes... dp = what are the states
2. Ask yourself what algorithm can I use to solve
3. Ask yourself what are the edge cases...
4. Edge cases = no disjoint sets
5. Disjoint sets = covers the entire graph... no forests. Use Union find algorithm to cover edge cases like aa bc cd de which have two forests. then use Euler's algorithm

Problem: POJ 1985 (Problem 9 Week 4)
Origin: http://poj.org/problem?id=1984
Learned: I actually solved it!!! (With dfs instead of supposed BFS)
1. DFS with memoization...
2. can also do with BFS
3. Ask yourself what are the nodes, edges -> algorithm -> what are the edge cases ... -> how can I memoize??? -> implement.

Problem: POJ (Problem 11 Week 4)
Origin: https://github.com/nanwan03/poj/blob/master/2186%20Popular%20Cows.java
Learned: 1. union find does not solve everything 2. SCC -> turn into its own Acyclic Directed Graph 3. The tree with dfn[u] = 0;

Problem: ModernArt *
Origin: http://usaco.org/current/data/sol_art2_gold_open17.html
Learned: 1. Ad Hoc 2. Use stack 3. Confusing ad hoc with weird optimizations (Redo)

Problem: Bovine Genomics *
Origin: http://usaco.org/index.php?page=viewproblem2&cpid=741
Learned: Hashing with sets. Simplify to O(NM) solution. Use hashing roll over technique! i++, j++ simplification!

Problem: Codeforces 723E * (redo with legit version...)
Origin: http://codeforces.com/contest/723/status/E (Read the java solutions they are good)
1) Improve Java by reading codeforces... 2) Switch to codeforces mainly... 3) Have fun and get in flow
4) Nice observation that there must be an even # of the vertices with odd degree. 5. We can just connect all odd degrees
and then print out the euler's tour of that graph (make it directed by starting at any vertice) (make sure not to print out fake graph)
6. Good observation/trick or you can point all vertices to 0 degree :D and dfs euler's tour. 8. Or do it legitly with an edge class...

Problem: Codeforces 508D
Origin: http://codeforces.com/contest/508/status/D
Learned: 1) Yeah basically Euler's + hash function... watch out for all typical conditions...
2) 256 * 256 covers all 'A' and 'a'; 3) Check in degree vs outdegree 4) dfs in unique ways!!!
5) Use fast scanner!!!

Problem: Codeforces 510C
Origin: http://codeforces.com/problemset/problem/510/C
Learned: 1) cycle algorithm 2) visited algorithm 3) you can do bfs too just check the size of the graph!!!
4) Edge case!

Problem: Codeforces 427C
Origin: http://codeforces.com/contest/427/problem/C
Learned: 1) reviewed kosaraju 2) programming is fun 3) love first 4) fast and furious
5) you can do the addition sometimes in the dfs or in the while stack!!!
