1. Compiler allows memory box to hold any subtype.
2. Compiler allows calls based on static type.
3.  Overridden non-static methods are selected at run time based on dynamic type. @Override (= changes the dynamic type regardless of new)
Everything else is based on static type (including assignment and new instance methods), including overloaded methods. Note: No overloaded methods for problem at left.
4. To use subclass method otherwise you must typecast
5. You can type cast any superclass static type into any of its subclass but not the other way around.
6. Method type is the declared type in their function
7. You can cast up if your variable's declaration is a superclass even though its initialization is a subclass
8. Class order = go up until you find the class
9. Arrays hold reference to value of variable
(can do temp reassignment)

Examples: 
a = c;
12 ((Cat) a).greet(); // (D) Cat Garfield says: Meow!
13 a.greet(); // (E) Cat Garfield says: Meow!

a = new Dog("Spot", 10);
d = a; // Error
d = (Dog) a //not a overriden nonstatic method

A c0 = new C();
A a1 = (A) c0;
C c2 = (C) a1;
//no error //no super.super ...

VengefulSList<Integer> vsl = new VengefulSList<Integer>(9);
vsl.insertBack(50);
SList<Integer> sl = vsl;
vsl.deleteBack();	
sl.printLostItems(); //Error because it is not a overridden nonstatic method

List61B<String> someList = new Slist<string>();
someList.insertFront("elk"); //No error

Static vs nonstatic
static Methods = Dog.maxDog
nonstatic = mydog.maxDog
Static variables should be accessed using the name of the class rather than a specific instance, e.g. you should use Dog.binomen, not d.binomen. 

Static type vs dynamic type
declaration = static type
compile time type = declaration  List61B<String>
runtime type dynamic type = new Slist<String> ();

If the nested class has no need to use any of the instance methods or variables of SLList

This:
Above, we use the keyword this to refer to the current object. This method could be invoked, for example.
return this this.a this.b; this.reverseString()

Private vs Public:
Private variables and methods can only be accessed by code inside the same .java file, e.g. in this case SLList.java
Public = Accessible everywhere

Classes:
The Dog class has its own variables, also known as instance variables. These must be declared inside the class
The method that we created in the Dog class did not have the static keyword. We call such methods instance methods or non-static methods.
The constructor with signature public Dog(int w) will be invoked anytime that we try to create a Dog using the new keyword and a single integer parameter. 

extends for other classes, implements for interfaces.
A subclass inherits all of the public and protected members of its parent, no matter what package the subclass is in
You can write a new instance method in the subclass that has the same signature as the one in the superclass, thus overriding it.
You can write a new static method in the subclass that has the same signature as the one in the superclass, thus hiding it.
You can declare new methods in the subclass that are not in the superclass.
You can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword super.

Casting: (A) new (C)

Nested class:
A nested class has access to all the private members of its enclosing classâ€”both fields and methods. Therefore, a public or protected nested class inherited by a subclass has indirect access to all of the private members of the superclass.

With static you cannot call any other public variables?

Interfaces:
Cannot have static methods
Cannot be instantiated.
Can provide either abstract or concrete methods.
Use no keyword for abstract methods.
Use default keyword for concrete methods.
Can provide only public static final variables.
Can provide only public methods.
Can have variables with this interface

Abstract Classes:
Cannot be instantiated.
Can provide either abstract or concrete methods.
Use abstract keyword for abstract methods.
Use no keyword for concrete methods.
Can provide variables (any kind).
Can provide methods (any kind).
Only 1 abstract class

public abstract class GraphicObject {
   // declare fields
   // declare nonabstract methods
   abstract void draw();
}

Abstract method:
abstract void moveTo(double deltaX, double deltaY);
If a class includes abstract methods, then the class itself must be declared abstract.When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.

Higher Order function:
public interface OurComparable {
   int compareTo(Object obj);
} /* interface */
//class implements it
public class Dog implements OurComparable {
	public int compareTo(OurComparable obj) {
		/** Warning, cast can cause runtime error! */
		Dog uddaDog = (Dog) obj;
		return this.size - uddaDog.size;
}
//real class that calls it
public class Maximizer {
	public static OurComparable max(OurComparable[] a) {
	...
}
(Dogs) Maximizer.max(dogs)

public interface Comparable<T> {
     public int compareTo(T obj);
} 
public int compareTo(Dog uddaDog) {
    	return this.size - uddaDog.size;
}
Dog largest = Arrays.sort(dogs);



