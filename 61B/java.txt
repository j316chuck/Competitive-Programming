Buffered Reader:
1. .read() and .readLine();

String Tokenizer:

Printing out:
1. System.StdOut.printf("%d", 3);
2.

Java Collection:
1. Use equals to compare.
2. add(object)
3. contains(object)
4. remove(object)
5. removeAll(collectoin)
6. size()

ArrayList:

Hashmap:

Hashset:

Treeset:

Strings:

Comparable:

Packages:
1. Packages are namespaces
2. Packages represent entire website name
3. Syntax: org.junit.Assert.assertEquals(5,5)
must use entire canonical name (unless from another class in smae package)
4. put package at top of file 
package ug.joshh.animal;
5. import org.junit.Assert; to import file
or import static members; import static org.junit.Assert.assertEquals;
6. Wildcard import * is bad because causes compile error if two static members with same name

Casting and Classes
1. Compiler allows memory box to hold any subtype.
2. Compiler allows calls based on static type.
3.  Overridden non-static methods are selected at run time based on dynamic type. @Override (= changes the dynamic type regardless of new)
Everything else is based on static type (including assignment and new instance methods), including overloaded methods. Note: No overloaded methods for problem at left.
(IF STATIC USES STATIC METHOD THEN)
4. To use subclass method otherwise you must typecast
5. You can type cast any superclass static type into its subclass (not necessarily if the superclass static type has a dynamic type of different class)
6. Method type is the declared type in their function
7. You can cast up if your variable's declaration is a superclass even though its initialization is a subclass
8. Class order = go up until you find the class
9. Arrays hold reference to value of variable
(can do temp reassignment)
10. You always initialize abstract and interface objects by their subclasses.
11. Signatures can take subclasses. public int method(Object obj) (can pass in anything)

Examples: 
a = c;
((Cat) a).greet(); // (D) Cat Garfield says: Meow!
a.greet(); // (E) Cat Garfield says: Meow!

Cannot Do
Animal a = new Dog();
Dog d = a; a is animal
Can Do
d = (Dog) a; totally fine!!!

a = new Dog("Spot", 10);
d = a; // Error
d = (Dog) a //not a overriden nonstatic method

A c0 = new C();
A a1 = (A) c0;
C c2 = (C) a1;
//no error //no super.super ...

VengefulSList<Integer> vsl = new VengefulSList<Integer>(9);
vsl.insertBack(50);
SList<Integer> sl = vsl;
vsl.deleteBack();	
sl.printLostItems(); //Error because it is not a overridden nonstatic method

List61B<String> someList = new Slist<string>();
someList.insertFront("elk"); //No error

Static vs nonstatic:
1. static Methods = Dog.maxDog
2. nonstatic = mydog.maxDog
3. Static variables should be accessed using the name of the class rather than a specific instance, e.g. you should use Dog.binomen, not d.binomen. 

Static type vs dynamic type:
1. declaration = static type
2. compile time type = declaration  List61B<String>
runtime type dynamic type = new Slist<String> ();

This:
1. Above, we use the keyword this to refer to the current object. This method could be invoked
2. for example: return this this.a this.b; this.reverseString()

Private vs Public:
1. Private variables and methods can only be accessed by code inside the same .java file, e.g. in this case SLList.java
2.Public = Accessible everywhere
3. (Not public static)

Classes:
1. The Dog class has its own variables, also known as instance variables. These must be declared inside the class
2. The method that we created in the Dog class did not have the static keyword. We call such methods instance methods or non-static methods.
3. The constructor with signature public Dog(int w) will be invoked anytime that we try to create a Dog using the new keyword and a single integer parameter. 
4. Any subclass automatically calls super(); overrides if we call this() first or super(x) etc.
extends for other classes, implements for interfaces.
5. A subclass inherits all of the public and protected members of its parent, no matter what package the subclass is in
6. You can write a new instance method in the subclass that has the same signature as the one in the superclass, thus overriding it.
7. You can write a new static method in the subclass that has the same signature as the one in the superclass, thus hiding it.
8. You can declare new methods in the subclass that are not in the superclass. (however be careful of using dynamic subclass types that have functions that are not in the original class... it must override or will cause compile error);
9. You can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword super.
No super.super super(x) 
10. Other classes can call your public static by doing main.getmapView() vs just public by doing obj.getmapview();

Nested class:
1. A nested class has access to all the private members of its enclosing classâ€”both fields and methods. 
2. Therefore, a public or protected nested class inherited by a subclass has indirect access to all of the private members of the superclass.
3. public static = does not use any of methods;

Interfaces:
1. Cannot have static methods
2. Cannot be instantiated.
3. Can provide either abstract or concrete methods.
4. Use no keyword for abstract methods.
5. Use default keyword for concrete methods.
6. Can provide only public static final variables.
7. Can provide only public methods.
8. Can have variables with this interface

Abstract Classes:
1. Cannot be instantiated.
2. Can provide either abstract or concrete methods.
3. Use abstract keyword for abstract methods.
4. Use no keyword for concrete methods.
5. Can provide variables (any kind).
6. Can provide methods (any kind).
7. Only 1 abstract class

public abstract class GraphicObject {
   // declare fields
   // declare nonabstract methods
   abstract void draw();
}

Abstract method:
1. abstract void moveTo(double deltaX, double deltaY);
2. If a class includes abstract methods, then the class itself must be declared abstract.
3. When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.

Higher Order function:
public interface OurComparable<T> {
   int compareTo(Object obj);
} /* interface */
//class implements it
public class Dog implements OurComparable<T> {
	public int compareTo(OurComparable obj) {
		/** Warning, cast can cause runtime error! */
		Dog uddaDog = (Dog) obj;
		return this.size - uddaDog.size;
}
//real class that calls it
public class Maximizer {
	public static OurComparable max(OurComparable[] a) {
	...
}
(Dogs) Maximizer.max(dogs)

public interface Comparable<T> {
     public int compareTo(T obj);
} 
public int compareTo(Dog uddaDog) {
    	return this.size - uddaDog.size;
}
Dog largest = Arrays.sort(dogs);d

Compile vs Runtime Error:
1. discountVariable = (DiscountSale) saleVariable; (run-time error)
2. discount Variable = saleVariable (compile error)
3. Compile Error = 1. syntax errors, type checking error. 
4. Run Time Error: Division by zero, referencing a null pointer, running out of memory, trying to open a file not there, casting wrong. array list out of bounds. (Indexout of bounds) (Casting) (overflow) (out of memory)


