Generics:
1. Java automatically autobox and unbox from same primitive to wrapper class.
2. You may need to widen or shorten going from different classes.
3. All generic data structures (arraylists etc) use generics
4. Boolean, Integer, etc..
5. Used to be ArrayList<Integer> L = new ArrayList<Integer>(); L.add(new Integer(5)); but now it's just L.add(5);
6. Arrays are never autoboxed/unboxed... Integer[] and int[] cannot be used vice versa.
7. Wrapper class = object = use much more performancel;
Integer x = new Integer(20);
8. Wrapper memory Integer x (64) = new (64) Integer(5) (32) = 160

Final:
1. Declare public final int month; = cannot reassign object.
2. public final ArrayDeque<String> d = new ArrayDeque<String>();
3. d can still be mutated just not reassigned to a new ArrayDeque<String>

AssertEquals/Autoboxing rules:
1. AssertEquals (Uses long long)
2. You can widen int to long, unbox integer to int and widen int to long.
3. unbox = int x = new Integer(5);
4. boxing Integer x = new Integer(5);
5. widening: long y = new Integer(5); okay 
but shortening short y = new Integer(5); not okay 
byte, short, int, long, float, double
7. assertEquals((Integer) expected, am.get(2)); or (expected, (int) am.get(2))
8. Method calls -> widening > boxing > varargs
(no shortening allowed) 
9. public static void m(int i) can pass in short s but not long s
public static void m(Integer i) short s would go in the first m
(even if it's Short i) it would still be first m

Generic Methods:
1. can create method that operates on generic types by defining type paramters BEFORE THE RETURN TYPE of the METHOD:
2. public static <X, Zerp> Zerp get(ArrayMap<X, Zerp> am, X key)
	if(am.containsKey(key))
		return a.get(key);
3. public static <K extends Comparable<K>, V> K maxKey(Arraymap<K, V> am) meaning K must have a camparable<T> 

Covariance:
1. Also, can use ? for all cases
public static void allBark(ArrayMap<Dog, ?> am)
2. However, arrays are covariant in java but generic types are invariant. 
3. Thus arrays FrenchDog is a dog good but generic List<FrenchDog> is not a List<Dog>
4. Fixes = public static <K extends Dog> void allBark(ArrayMap<K, ?> am
5. public static void allBark(ArrayMap<? extends Dog, ?> am)

Equals vs ==:
1. Integers and Long and int compare with == and > < (everything else is .equals())
2. == is reference location. .equals() is comparison of values in objects 

Variable Args:
1. you can take in as much arguments;
2. Syntax: public static void vaTest(int ... no){
      for(int n : no)System.out.print(n + " ");
}
