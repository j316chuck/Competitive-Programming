
General Time Break Down:
Finish in 3 hours. 45 45 1 hour 30 minutes.
KEY OBSERVATION!!!!

General Debugging Tips:
If you get stuck skip to next problem give yourself at least 1 and a half hours per problem.
If you get stuck try a different solution. 
If your code does not work/ X per test cases...try to debug it by running through code 3 times and 
checking where code went wrong.

General Solving Pattern:
THERE IS NO SUCH THING AS FAST CODING. CODE CAREFULLY. CORRECT FIRST TIME > TRY AGAIN OVER AND OVER. Do a lot of testing... and CF problems
Read one by one: You must first read problem slowly. (5 minutes) 
Design algorithm slowly but carefully. Go fast and slow. Problem Type, RunTime, Algorithm, Implementation, Tricks (25 minutes)
Make sure algorithm runs in time AND is codable in 15 minutes. (15 minutes code) (fast code but slow). 
KEY OBSERVATION
How can I write the least amount of code in 15 minutes. Always make sure the solution runs in time < 10^8 preferably 10^7
Keep it simple!!! You must know how to code it!!!

Ad HOC: Start from back/reorder/shift by one = common pattern/trick. Also don't forget prefix sums. Use vector then sets as last option...
Make sure you don't have decimals = use modulus... use classes, maps, etc. to organize data.

Note: Array size < 10 million vector < 1 million 2d < 100,000
DP: = Simple, Try memoization if you cannot figure out DP after 15 minutes. what does i, j represent... write it down.
Top Down: Memo
Bottom Up: DP
3 Patterns, Typical dp, dp[i][k] = dp[i-1][k-1] + dp[i-1][k].  Interval dp, dp[i][k] (i = length, k = last position) = sum of (dp[i-1][j] + f(j, k))
Memo...

Common: LIS
for (i = 1; i < n; i++ )
        for (j = 0; j < i; j++ ) 
            if ( arr[i] > arr[j] && lis[i] < lis[j] + 1)
                lis[i] = lis[j] + 1;

GRAPH = Simple, ... often has DP and storing/memoizing results in it. Also remember XtoY simplification

BFS-> too slow usually, 
Dijstrka Queue -> O(E log V),
Kruskal O(E log V) or O(E log E sort)  Prim O(V^2)
DP keep it simple :D, mem < 10 million;
String: Think of hashing lol. 
Ad Hoc: brute force vs smart...
BIT: lol range queries


