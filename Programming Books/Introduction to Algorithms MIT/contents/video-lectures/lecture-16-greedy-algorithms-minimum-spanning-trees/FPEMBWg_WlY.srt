1
00:00:07,000 --> 00:00:12,000
-- valuable experience.
OK, today we're going to start

2
00:00:12,000 --> 00:00:18,000
talking about a particular class
of algorithms called greedy

3
00:00:18,000 --> 00:00:22,000
algorithms.
But we're going to do it in the

4
00:00:22,000 --> 00:00:27,000
context of graphs.
So, I want to review a little

5
00:00:27,000 --> 00:00:32,000
bit about graphs,
which mostly you can find in

6
00:00:32,000 --> 00:00:39,000
the textbook in appendix B.
And so, if you haven't reviewed

7
00:00:39,000 --> 00:00:45,000
in appendix B recently,
please sit down and review

8
00:00:45,000 --> 00:00:50,000
appendix B.
It will pay off especially

9
00:00:50,000 --> 00:00:55,000
during our take-home quiz.
So, just reminder,

10
00:00:55,000 --> 00:01:01,000
a digraph, what's a digraph?
What's that short for?

11
00:01:01,000 --> 00:01:04,000
Directed graph,
OK?

12
00:01:04,000 --> 00:01:07,000
Directed graph,
G equals (V,E),

13
00:01:07,000 --> 00:01:13,000
OK, has a set,
V, of vertices.

14
00:01:13,000 --> 00:01:17,000
And, I always get people
telling me that I have one

15
00:01:17,000 --> 00:01:20,000
vertice.
The singular is not vertice;

16
00:01:20,000 --> 00:01:21,000
it is vertex,
OK?

17
00:01:21,000 --> 00:01:25,000
The plural is vertices.
The singular is vertex.

18
00:01:25,000 --> 00:01:29,000
It's one of those weird English
words.

19
00:01:29,000 --> 00:01:33,000
It's probably originally like
French or something,

20
00:01:33,000 --> 00:01:37,000
right?
I don't know.

21
00:01:37,000 --> 00:01:47,000
OK, anyway, and we have a set,
E, which is a subset of V cross

22
00:01:47,000 --> 00:01:52,000
V of edges.
So that's a digraph.

23
00:01:52,000 --> 00:02:02,000
And undirected graph,
E contains unordered pairs.

24
00:02:02,000 --> 00:02:12,000


25
00:02:12,000 --> 00:02:15,000
OK, and, sorry?
It's Latin, OK,

26
00:02:15,000 --> 00:02:21,000
so it's probably pretty old,
then, in English.

27
00:02:21,000 --> 00:02:28,000
I guess the vertex would be a
little bit of a giveaway that

28
00:02:28,000 --> 00:02:34,000
maybe it wasn't French.
It started to be used in 1570,

29
00:02:34,000 --> 00:02:39,000
OK.
OK, good, OK,

30
00:02:39,000 --> 00:02:52,000
so the number of edges is,
whether it's directed or

31
00:02:52,000 --> 00:03:02,000
undirected, is O of what?
V^2, good.

32
00:03:02,000 --> 00:03:05,000
OK, and one of the conventions
that will have when we're

33
00:03:05,000 --> 00:03:09,000
dealing, once we get into
graphs, we deal a lot with sets.

34
00:03:09,000 --> 00:03:13,000
We generally drop the vertical
bar notation within O's just

35
00:03:13,000 --> 00:03:16,000
because it's applied.
It just makes it messier.

36
00:03:16,000 --> 00:03:18,000
So, once again,
another abuse of notation.

37
00:03:18,000 --> 00:03:22,000
It really should be order the
size of V^2, but it just messes

38
00:03:22,000 --> 00:03:25,000
up, I mean, it's just more stuff
to write down.

39
00:03:25,000 --> 00:03:29,000
And, you're multiplying these
things, and all those vertical

40
00:03:29,000 --> 00:03:33,000
bars.
Since they don't even have a

41
00:03:33,000 --> 00:03:36,000
sense to the vertical bar,
it gets messy.

42
00:03:36,000 --> 00:03:40,000
So, we just drop the vertical
bars there when it's in

43
00:03:40,000 --> 00:03:44,000
asymptotic notation.
So, E is order V^2 when it's a

44
00:03:44,000 --> 00:03:48,000
set of pairs,
because if it's a set of pairs,

45
00:03:48,000 --> 00:03:52,000
it's at most n choose two,
which is where it's at most n^2

46
00:03:52,000 --> 00:03:56,000
over 2, here it could be,
at most, sorry,

47
00:03:56,000 --> 00:04:00,000
V^2 over 2, here it's at most
V^2.

48
00:04:00,000 --> 00:04:07,000
And then, another property that
sometimes comes up is if the G

49
00:04:07,000 --> 00:04:11,000
is connected,
we have another bound,

50
00:04:11,000 --> 00:04:18,000
implies that the size of E is
at least the size of V minus

51
00:04:18,000 --> 00:04:22,000
one.
OK, so if it's connected,

52
00:04:22,000 --> 00:04:31,000
meaning, what does it mean to
have a graph that's connected?

53
00:04:31,000 --> 00:04:37,000
Yeah, there's a path from any
vertex to any other vertex in

54
00:04:37,000 --> 00:04:40,000
the graph.
That's what it means to be

55
00:04:40,000 --> 00:04:44,000
connected.
So if that's the case,

56
00:04:44,000 --> 00:04:50,000
that a number of edges is at
least the number of vertices

57
00:04:50,000 --> 00:04:53,000
minus one, OK?
And so, what that says,

58
00:04:53,000 --> 00:05:00,000
so one of the things we'll get
into, a fact that I just wanted

59
00:05:00,000 --> 00:05:04,000
to remind you,
is that in that case,

60
00:05:04,000 --> 00:05:09,000
if I look at log E,
OK, log of the number of edges,

61
00:05:09,000 --> 00:05:14,000
that is O of log V.
And by this,

62
00:05:14,000 --> 00:05:18,000
is omega of log V.
So, it's equal to theta of log

63
00:05:18,000 --> 00:05:21,000
V.
OK, so basically the number of,

64
00:05:21,000 --> 00:05:25,000
in the case of a connected
graph, the number of edges,

65
00:05:25,000 --> 00:05:30,000
and the number of vertices are
polynomially related.

66
00:05:30,000 --> 00:05:36,000
So, their logs are comparable.
OK, so that's helpful just to

67
00:05:36,000 --> 00:05:41,000
know because sometimes I just
get questions later on where

68
00:05:41,000 --> 00:05:45,000
people will say,
oh, you showed it was log E but

69
00:05:45,000 --> 00:05:51,000
you didn't show it was log V.
And I could point out that it's

70
00:05:51,000 --> 00:05:55,000
the same thing.
OK, so there's various ways of

71
00:05:55,000 --> 00:05:59,000
representing graphs in
computers, and I'm just going to

72
00:05:59,000 --> 00:06:04,000
cover a couple of the important
ones.

73
00:06:04,000 --> 00:06:11,000
There's actually more.
We'll see some more.

74
00:06:11,000 --> 00:06:20,000
So, the simplest one is what's
called an adjacency matrix.

75
00:06:20,000 --> 00:06:30,000
An adjacency matrix of the
graph, G, equals (V,E),

76
00:06:30,000 --> 00:06:40,000
where, for simplicity,
I'll let V be the set of

77
00:06:40,000 --> 00:06:52,000
integers from one up to n,
OK, is the n by n matrix A

78
00:06:52,000 --> 00:07:04,000
given by the ij-th at the entry
is simply one if the edge,

79
00:07:04,000 --> 00:07:20,000
ij, is in the edge set and zero
if ij is not in the edge set.

80
00:07:20,000 --> 00:07:22,000
OK, so it's simply the matrix
where you say,

81
00:07:22,000 --> 00:07:25,000
the ij entry is one if it's in
the matrix.

82
00:07:25,000 --> 00:07:27,000
So, this is,
in some sense,

83
00:07:27,000 --> 00:07:32,000
giving you the predicate for,
is there an edge from i to j?

84
00:07:32,000 --> 00:07:35,000
OK, remember,
predicate is Boolean formula

85
00:07:35,000 --> 00:07:39,000
that is either zero or one,
and in this case,

86
00:07:39,000 --> 00:07:45,000
you're saying it's one if there
is an edge from i to j and zero

87
00:07:45,000 --> 00:07:48,000
otherwise.
OK, sometimes you have edge

88
00:07:48,000 --> 00:07:52,000
weighted graphs,
and then sometimes what people

89
00:07:52,000 --> 00:07:56,000
will do is replace this by edge
weights.

90
00:07:56,000 --> 00:08:02,000
OK, it will be the weight of
the edge from i to j.

91
00:08:02,000 --> 00:08:12,000
So, let's just do an example of
that just to make sure that our

92
00:08:12,000 --> 00:08:22,000
intuition corresponds to our
mathematical definitions.

93
00:08:22,000 --> 00:08:33,000
So, here's an example graph.
Let's say that's our graph.

94
00:08:33,000 --> 00:08:37,000
So let's just draw the
adjacency the matrix.

95
00:08:37,000 --> 00:08:42,000
OK, so what this says:
is there's an edge from one to

96
00:08:42,000 --> 00:08:44,000
one?
And the answer is no.

97
00:08:44,000 --> 00:08:47,000
Is there an edge from one to
two?

98
00:08:47,000 --> 00:08:50,000
Yes.
Is there an edge from one to

99
00:08:50,000 --> 00:08:51,000
three here?
Yep.

100
00:08:51,000 --> 00:08:54,000
Is there an edge for one to
four?

101
00:08:54,000 --> 00:08:58,000
No.
Is there an edge from two until

102
00:08:58,000 --> 00:09:00,000
one?
No.

103
00:09:00,000 --> 00:09:02,000
Two to two?
No.

104
00:09:02,000 --> 00:09:04,000
Two to three?
Yes.

105
00:09:04,000 --> 00:09:06,000
Two to four?
No.

106
00:09:06,000 --> 00:09:13,000
No edges going out of three.
Edge from four to three,

107
00:09:13,000 --> 00:09:19,000
and that's it.
That's the adjacency matrix for

108
00:09:19,000 --> 00:09:23,000
this particular graph,
OK?

109
00:09:23,000 --> 00:09:33,000
And so, I can represent a graph
as this adjacency matrix.

110
00:09:33,000 --> 00:09:43,000
OK, when I represent it in this
way, how much storage do I need?

111
00:09:43,000 --> 00:09:52,000
OK, n^2 or V^2 because the size
is the same thing for V^2

112
00:09:52,000 --> 00:10:03,000
storage, OK, and that's what we
call a dense representation.

113
00:10:03,000 --> 00:10:06,000
OK, it works well when the
graph is dense.

114
00:10:06,000 --> 00:10:11,000
So, the graph is dense if the
number of edges is close to all

115
00:10:11,000 --> 00:10:14,000
of the edges possible.
OK, then this is a good

116
00:10:14,000 --> 00:10:18,000
representation.
But for many types of graphs,

117
00:10:18,000 --> 00:10:23,000
the number of edges is much
less than the possible number of

118
00:10:23,000 --> 00:10:26,000
edges, in which case we say the
graph is sparse.

119
00:10:26,000 --> 00:10:32,000
Can somebody give me an example
of a sparse graph?

120
00:10:32,000 --> 00:10:35,000
A class of graphs:
so, I want a class of graphs

121
00:10:35,000 --> 00:10:38,000
that as n grows,
the number of edges in the

122
00:10:38,000 --> 00:10:42,000
graph doesn't grow as the
square, but grows rather as

123
00:10:42,000 --> 00:10:45,000
something much smaller.
A linked list,

124
00:10:45,000 --> 00:10:48,000
so, a chain,
OK, if you look at it from a

125
00:10:48,000 --> 00:10:52,000
graph theoretically,
is a perfectly good example:

126
00:10:52,000 --> 00:10:56,000
only n edges in the chain for a
chain of length n.

127
00:10:56,000 --> 00:10:59,000
So therefore,
the number of edges would be

128
00:10:59,000 --> 00:11:02,000
order V.
And in particular,

129
00:11:02,000 --> 00:11:07,000
you'd only have one edge per
row here.

130
00:11:07,000 --> 00:11:10,000
What other graphs are sparse?
Yeah?

131
00:11:10,000 --> 00:11:16,000
Good, a planar graph,
a graph that can be drawn in a

132
00:11:16,000 --> 00:11:21,000
plane turns out that if it has V
vertices has,

133
00:11:21,000 --> 00:11:25,000
and V is at least three,
then it has,

134
00:11:25,000 --> 00:11:30,000
at most, three V minus six
edges.

135
00:11:30,000 --> 00:11:34,000
So, it turns out that's order V
edges again.

136
00:11:34,000 --> 00:11:38,000
What's another example of a
common graph?

137
00:11:38,000 --> 00:11:42,000
Yeah, binary tree,
or even actually any tree,

138
00:11:42,000 --> 00:11:49,000
you know, what's called a free
tree if you read the appendix,

139
00:11:49,000 --> 00:11:54,000
OK, a tree that just is a
connected graph that has no

140
00:11:54,000 --> 00:12:00,000
cycles, OK, is another example.
What's an example of a graph

141
00:12:00,000 --> 00:12:04,000
that's dense?
A complete graph,

142
00:12:04,000 --> 00:12:07,000
OK: it's all ones,
OK, or if you have edge

143
00:12:07,000 --> 00:12:11,000
weights, it would be a
completely filled in matrix.

144
00:12:11,000 --> 00:12:14,000
OK, good.
So, this is good for dense

145
00:12:14,000 --> 00:12:17,000
representation.
But sometimes you want to have

146
00:12:17,000 --> 00:12:22,000
a sparse representation so we
don't have to spend V^2 space to

147
00:12:22,000 --> 00:12:26,000
deal with all of the,
where most of it's going to be

148
00:12:26,000 --> 00:12:28,000
zeroes.
OK, it's sort of like,

149
00:12:28,000 --> 00:12:33,000
if we know why it's zero,
why bother representing it as

150
00:12:33,000 --> 00:12:40,000
zero?
So, one such representation is

151
00:12:40,000 --> 00:12:46,000
an adjacency list
representation.

152
00:12:46,000 --> 00:12:56,000
Actually, adjacency list of a
given vertex is the list,

153
00:12:56,000 --> 00:13:08,000
which we denote by Adj of V,
of vertices adjacent to V.

154
00:13:08,000 --> 00:13:12,000
OK, just in terms by their
terminology, vertices are

155
00:13:12,000 --> 00:13:17,000
adjacent, but edges are incident
on vertices.

156
00:13:17,000 --> 00:13:22,000
OK, so the incidence is a
relation between a vertex and an

157
00:13:22,000 --> 00:13:25,000
edge.
An adjacency is a relation

158
00:13:25,000 --> 00:13:31,000
between two vertices.
OK, that's just the language.

159
00:13:31,000 --> 00:13:36,000
Why they use to different
terms, I don't know,

160
00:13:36,000 --> 00:13:40,000
but that's what they do.
So, in the graph,

161
00:13:40,000 --> 00:13:45,000
for example,
the adjacency list for vertex

162
00:13:45,000 --> 00:13:52,000
one is just the list or the set
of two three because one has

163
00:13:52,000 --> 00:13:57,000
going out of one are edges to
two and three.

164
00:13:57,000 --> 00:14:02,000
The adjacency list for two is
just three, four,

165
00:14:02,000 --> 00:14:07,000
three.
It's the empty set,

166
00:14:07,000 --> 00:14:10,000
and for four,
it is three.

167
00:14:10,000 --> 00:14:13,000
OK, so that's the
representation.

168
00:14:13,000 --> 00:14:21,000
Now, if we want to figure out
how much storage is required for

169
00:14:21,000 --> 00:14:26,000
this representation,
OK, we need to understand how

170
00:14:26,000 --> 00:14:35,000
long the adjacency list is.
So, what is the length of an

171
00:14:35,000 --> 00:14:40,000
adjacency list of a vertex,
V?

172
00:14:40,000 --> 00:14:48,000
What name do we give to that?
It's the degree.

173
00:14:48,000 --> 00:14:57,000
So, in an undirected graph,
we call it the degree of the

174
00:14:57,000 --> 00:15:02,000
vertex.
This is undirected.

175
00:15:02,000 --> 00:15:07,000
OK, about here,
OK.

176
00:15:07,000 --> 00:15:12,000
So that's an undirected case.
In the directed case,

177
00:15:12,000 --> 00:15:18,000
OK, actually I guess the way we
should do this is say this.

178
00:15:18,000 --> 00:15:22,000
If the degree,
we call it the out degree for a

179
00:15:22,000 --> 00:15:25,000
digraph.
OK, so in a digraph,

180
00:15:25,000 --> 00:15:32,000
we have an out degree and an in
degree for each vertex.

181
00:15:32,000 --> 00:15:36,000
So here, the in degree is
three.

182
00:15:36,000 --> 00:15:41,000
Here, the out degree is two,
OK?

183
00:15:41,000 --> 00:15:50,000
So, one of the important lemma
that comes up is what's called

184
00:15:50,000 --> 00:15:56,000
the handshaking lemma.
OK, it's one of these

185
00:15:56,000 --> 00:16:01,000
mathematical lemmas.

186
00:16:01,000 --> 00:16:11,000


187
00:16:11,000 --> 00:16:16,000
And so, it comes from a story.
Go to a dinner party,

188
00:16:16,000 --> 00:16:21,000
and everybody at the dinner
party shakes other people's

189
00:16:21,000 --> 00:16:24,000
hands.
Some people may not shake

190
00:16:24,000 --> 00:16:29,000
anybody's hand.
Some people may shake several

191
00:16:29,000 --> 00:16:32,000
people's hands.
Nobody shakes hands with

192
00:16:32,000 --> 00:16:37,000
themselves.
And at some point during the

193
00:16:37,000 --> 00:16:41,000
dinner party,
the host goes around and counts

194
00:16:41,000 --> 00:16:45,000
up how many, the sum,
of the number of hands that

195
00:16:45,000 --> 00:16:48,000
each person has shaken.
OK, so he says,

196
00:16:48,000 --> 00:16:52,000
how many did you shake?
How many did you shake?

197
00:16:52,000 --> 00:16:55,000
How many did you shake?
He adds them up,

198
00:16:55,000 --> 00:17:00,000
OK, and that number is
guaranteed to be even.

199
00:17:00,000 --> 00:17:03,000
OK, that's the handshaking
lemma.

200
00:17:03,000 --> 00:17:08,000
Or, stated a little bit more
precisely, if I take for any

201
00:17:08,000 --> 00:17:13,000
graph the degree of the vertex,
and sum them all up,

202
00:17:13,000 --> 00:17:20,000
that's how many hands everybody
shook, OK, that's actually equal

203
00:17:20,000 --> 00:17:23,000
to always twice the number of
edges.

204
00:17:23,000 --> 00:17:26,000
So, why is that going to be
true?

205
00:17:26,000 --> 00:17:33,000
Why is that going to be twice
the number of edges?

206
00:17:33,000 --> 00:17:33,000
Yeah?
Yeah.
Every time you put in an edge,
you add one to the degree of

207
00:17:39,000 --> 00:17:44,000
each person on each end.
So, it's just two different

208
00:17:44,000 --> 00:17:48,000
ways of counting up the same
number of edges.

209
00:17:48,000 --> 00:17:52,000
OK, I can go around,
and if you imagine that,

210
00:17:52,000 --> 00:17:56,000
that every time I count the
degree of the node,

211
00:17:56,000 --> 00:18:01,000
I put a mark on every edge.
Then, when I'm done,

212
00:18:01,000 --> 00:18:07,000
every edge has two marks on it,
one for each end.

213
00:18:07,000 --> 00:18:17,000
OK: a pretty simple theorem.
So, what that says is that for

214
00:18:17,000 --> 00:18:26,000
undirected graphs,
that implies that the adjacency

215
00:18:26,000 --> 00:18:35,000
list representation,
uses how much storage?

216
00:18:35,000 --> 00:18:39,000
OK, at most,
2E, so order E because that's

217
00:18:39,000 --> 00:18:42,000
not all.
Yeah, so you have to have the

218
00:18:42,000 --> 00:18:47,000
number of vertices plus order
the number of edges,

219
00:18:47,000 --> 00:18:53,000
OK, whether it's directed or
undirected because I may have a

220
00:18:53,000 --> 00:18:59,000
graph, say it has a whole bunch
of vertices and no edges,

221
00:18:59,000 --> 00:19:05,000
that's still going to cost me
order V, OK?

222
00:19:05,000 --> 00:19:09,000
So, it uses theta of V plus E
storage.

223
00:19:09,000 --> 00:19:15,000
And, it's basically the same
thing asymptotically.

224
00:19:15,000 --> 00:19:22,000
In fact, it's easier to see in
some sense for digraphs because

225
00:19:22,000 --> 00:19:27,000
for digraphs,
what I do is I just add up the

226
00:19:27,000 --> 00:19:33,000
out degrees, and that equal to
E, OK, if I add up the out

227
00:19:33,000 --> 00:19:39,000
degrees as equally.
In fact, this is kind of like

228
00:19:39,000 --> 00:19:41,000
it amortized analysis,
if you will,

229
00:19:41,000 --> 00:19:45,000
a book keeping analysis,
that if I'm adding up the total

230
00:19:45,000 --> 00:19:48,000
number of edges,
one way of doing it is

231
00:19:48,000 --> 00:19:50,000
accounting for a vertex by
vertex.

232
00:19:50,000 --> 00:19:54,000
OK, so for each vertex,
I basically can take each

233
00:19:54,000 --> 00:19:58,000
degree, and basically each
vertex, look at the degree,

234
00:19:58,000 --> 00:20:02,000
and that allocating of account
per edge, and then ending up

235
00:20:02,000 --> 00:20:06,000
with twice the number of edges,
that's exactly accounting type

236
00:20:06,000 --> 00:20:12,000
of analysis that we might do for
amortized analysis.

237
00:20:12,000 --> 00:20:17,000
OK, so we'll see that.
So, this is a sparse

238
00:20:17,000 --> 00:20:22,000
representation,
and it's often better than an

239
00:20:22,000 --> 00:20:25,000
adjacency matrix.
For example,

240
00:20:25,000 --> 00:20:32,000
you can imagine if the World
Wide Web were done with an

241
00:20:32,000 --> 00:20:37,000
adjacency matrix as opposed to,
essentially,

242
00:20:37,000 --> 00:20:44,000
with an adjacency list type of
representation.

243
00:20:44,000 --> 00:20:47,000
Every link on the World Wide
Web, I had to say,

244
00:20:47,000 --> 00:20:50,000
here are the ones that I'm
connected to,

245
00:20:50,000 --> 00:20:53,000
and here are all the ones I'm
not connected to.

246
00:20:53,000 --> 00:20:57,000
OK, that list of things you're
not connected to for a given

247
00:20:57,000 --> 00:20:59,000
page would be pretty
dramatically,

248
00:20:59,000 --> 00:21:03,000
show you that there is an
advantage to sparse

249
00:21:03,000 --> 00:21:06,000
representation.
On the other hand,

250
00:21:06,000 --> 00:21:13,000
one of the nice things about an
adjacency matrix representation

251
00:21:13,000 --> 00:21:19,000
is that each edge can be
represented with a single bit,

252
00:21:19,000 --> 00:21:24,000
whereas typical when I'm
representing things with an

253
00:21:24,000 --> 00:21:30,000
adjacency list representation,
how many bits am I going to

254
00:21:30,000 --> 00:21:35,000
need to represent each
adjacency?

255
00:21:35,000 --> 00:21:39,000
You'll need order log of V to
be able to name each different

256
00:21:39,000 --> 00:21:41,000
vertex.
OK, the log of the number is

257
00:21:41,000 --> 00:21:46,000
the number of bits that I need.
So, there are places where this

258
00:21:46,000 --> 00:21:50,000
is actually a far more efficient
representation.

259
00:21:50,000 --> 00:21:53,000
In particular,
if you have a very dense graph,

260
00:21:53,000 --> 00:21:56,000
OK, this may be a better way of
representing it.

261
00:21:56,000 --> 00:22:01,000
OK, the other thing I want you
to get, and we're going to see

262
00:22:01,000 --> 00:22:05,000
more of this in particular next
week, is that a matrix and a

263
00:22:05,000 --> 00:22:11,000
graph, there are two ways of
looking at the same thing.

264
00:22:11,000 --> 00:22:14,000
OK, and in fact,
there's a lot of graph theory

265
00:22:14,000 --> 00:22:17,000
that when you do things like
multiply the adjacency matrix,

266
00:22:17,000 --> 00:22:20,000
OK, and so forth.
So, there's a lot of

267
00:22:20,000 --> 00:22:24,000
commonality between graphs and
matrices, a lot of mathematics

268
00:22:24,000 --> 00:22:28,000
that if it applies for one,
it applies to the other.

269
00:22:28,000 --> 00:22:31,000
Do you have a question,
or just holding your finger in

270
00:22:31,000 --> 00:22:33,000
the air?
OK, good.

271
00:22:33,000 --> 00:22:37,000
OK, so that's all just review.
Now I want to get onto today's

272
00:22:37,000 --> 00:22:40,000
lecture.
OK, so any questions about

273
00:22:40,000 --> 00:22:42,000
graphs?
So, this is a good time to

274
00:22:42,000 --> 00:22:45,000
review appendix B.
there are a lot of great

275
00:22:45,000 --> 00:22:48,000
properties in there,
and in particular,

276
00:22:48,000 --> 00:22:52,000
there is a theorem that we're
going to cover today that we're

277
00:22:52,000 --> 00:22:56,000
going to talk about today,
which is properties of trees.

278
00:22:56,000 --> 00:23:00,000
Trees are very special kinds of
graphs, so I really want you to

279
00:23:00,000 --> 00:23:05,000
go and look to see what the
properties are.

280
00:23:05,000 --> 00:23:08,000
There is, I think,
something like six different

281
00:23:08,000 --> 00:23:11,000
definitions of trees that are
all equivalent,

282
00:23:11,000 --> 00:23:16,000
OK, and so, I think a very good
idea to go through and read

283
00:23:16,000 --> 00:23:20,000
through that theorem.
We're not going to prove it in

284
00:23:20,000 --> 00:23:23,000
class, but really,
provides a very good basis for

285
00:23:23,000 --> 00:23:27,000
the thinking that we're going to
be doing today.

286
00:23:27,000 --> 00:23:30,000
And we'll see more of that in
the future.

287
00:23:30,000 --> 00:23:33,000
OK, so today,
we're going to talk about

288
00:23:33,000 --> 00:23:38,000
minimum spanning trees.
OK, this is one of the world's

289
00:23:38,000 --> 00:23:42,000
most important algorithms.
OK, it is important in

290
00:23:42,000 --> 00:23:46,000
distributed systems.
It's one of the first things

291
00:23:46,000 --> 00:23:50,000
that almost any distributed
system tries to find is a

292
00:23:50,000 --> 00:23:55,000
minimum spanning tree of the
nodes that happened to be alive

293
00:23:55,000 --> 00:23:56,000
at any point,
OK?

294
00:23:56,000 --> 00:24:01,000
And one of the people who
developed an algorithm for this,

295
00:24:01,000 --> 00:24:04,000
we'll talk about this a little
bit later, OK,

296
00:24:04,000 --> 00:24:09,000
it was the basis of the billing
system for AT&T for many years

297
00:24:09,000 --> 00:24:16,000
while it was a monopoly.
OK, so very important kind of

298
00:24:16,000 --> 00:24:21,000
thing.
It's got a huge number of

299
00:24:21,000 --> 00:24:25,000
applications.
So the problem is the

300
00:24:25,000 --> 00:24:31,000
following.
You have a connected undirected

301
00:24:31,000 --> 00:24:35,000
graph,
G equals (V,E),

302
00:24:35,000 --> 00:24:42,000
with an edge weight function,
w, which maps the edges into

303
00:24:42,000 --> 00:24:50,000
weights that are real numbers.
And for today's lecture,

304
00:24:50,000 --> 00:24:56,000
we're going to make an
important assumption,

305
00:24:56,000 --> 00:25:02,000
OK, for simplicity.
The book does not make this

306
00:25:02,000 --> 00:25:08,000
assumption.
And so, I encourage you to look

307
00:25:08,000 --> 00:25:16,000
at the alternative presentation
or, because what they do in the

308
00:25:16,000 --> 00:25:22,000
book is much more general,
but for simplicity and

309
00:25:22,000 --> 00:25:29,000
intuition, I'm going to make
this a little bit easier.

310
00:25:29,000 --> 00:25:37,000
We're going to assume that all
edge weights are distinct.

311
00:25:37,000 --> 00:25:39,000
OK, all edge weights are
distinct.

312
00:25:39,000 --> 00:25:42,000
So what does that mean?
What does that mean that this

313
00:25:42,000 --> 00:25:46,000
function, w, what property does
the function,

314
00:25:46,000 --> 00:25:48,000
w, have if all edge weights are
distinct?

315
00:25:48,000 --> 00:25:51,000
Who remembers their discreet
math?

316
00:25:51,000 --> 00:25:53,000
It's injective.
OK, it's one to one.

317
00:25:53,000 --> 00:25:56,000
OK, it's not one to one and
onto necessarily.

318
00:25:56,000 --> 00:26:00,000
In fact, it would be kind of
hard to do that because that's a

319
00:26:00,000 --> 00:26:05,000
pretty big set.
OK, but it's one to one.

320
00:26:05,000 --> 00:26:09,000
It's injective.
OK, so that's what we're going

321
00:26:09,000 --> 00:26:14,000
to assume for simplicity.
OK, and the book,

322
00:26:14,000 --> 00:26:19,000
they don't assume that.
It just means that the way you

323
00:26:19,000 --> 00:26:24,000
have to state things is just a
little more precise.

324
00:26:24,000 --> 00:26:28,000
It has to be more technically
precise.

325
00:26:28,000 --> 00:26:33,000
So, that's the input.
The output is--

326
00:26:33,000 --> 00:26:44,000
The output is a spanning tree,
T, and by spanning tree,

327
00:26:44,000 --> 00:26:52,000
we mean it connects all the
vertices.

328
00:26:52,000 --> 00:27:02,000
OK, and it's got to have
minimum weight.

329
00:27:02,000 --> 00:27:08,000
OK, so we can write the weight
of the tree is going to be,

330
00:27:08,000 --> 00:27:14,000
by that, we meet the sum over
all edges that are in the tree

331
00:27:14,000 --> 00:27:18,000
of the weight of the individual
edges.

332
00:27:18,000 --> 00:27:24,000
OK, so here I'(V,E) done a
little bit of abusive notation,

333
00:27:24,000 --> 00:27:31,000
which is that what I should be
writing is w of the edge (u,v)

334
00:27:31,000 --> 00:27:37,000
because this is a mapping from
edges, which would give me a

335
00:27:37,000 --> 00:27:42,000
double parentheses.
And, you know,

336
00:27:42,000 --> 00:27:45,000
as you know,
I love to abuse notation.

337
00:27:45,000 --> 00:27:48,000
So, I'm going to drop that
extra parentheses,

338
00:27:48,000 --> 00:27:54,000
because we understand that it's
really the weight of the edge,

339
00:27:54,000 --> 00:27:57,000
OK, not the weight of the
ordered pair.

340
00:27:57,000 --> 00:28:02,000
So, that's just a little
notational convenience.

341
00:28:02,000 --> 00:28:05,000
OK, so one of the things,
when we do the take-home exam,

342
00:28:05,000 --> 00:28:09,000
notational convenience can make
the difference between having a

343
00:28:09,000 --> 00:28:12,000
horrible time writing up a
problem, and an easy time.

344
00:28:12,000 --> 00:28:16,000
So, it's worth thinking about
what kinds of notation you'll

345
00:28:16,000 --> 00:28:19,000
use in writing up solutions to
problems, and so forth.

346
00:28:19,000 --> 00:28:22,000
OK, and just in general,
a technical communication,

347
00:28:22,000 --> 00:28:25,000
you adopt good notation people
understand you.

348
00:28:25,000 --> 00:28:29,000
You adopt a poor notation:
nobody pays attention to what

349
00:28:29,000 --> 00:28:34,000
you're doing because they don't
understand what you're saying.

350
00:28:34,000 --> 00:28:38,000
OK, so let's do an example.

351
00:28:38,000 --> 00:28:45,000


352
00:28:45,000 --> 00:28:52,000
OK, so here's a graph.
I think for this,

353
00:28:52,000 --> 00:29:02,000
somebody asked once if I was
inspired by biochemistry or

354
00:29:02,000 --> 00:29:09,000
something, OK,
but I wasn't.

355
00:29:09,000 --> 00:29:11,000
I was just writing these things
down, OK?

356
00:29:11,000 --> 00:29:15,000
So, here's a graph.
And let's give us some edge

357
00:29:15,000 --> 00:29:16,000
weights.

358
00:29:16,000 --> 00:29:31,000


359
00:29:31,000 --> 00:29:34,000
OK, so there are some edge
weights.

360
00:29:34,000 --> 00:29:39,000
And now, what we want is we
want to find a tree.

361
00:29:39,000 --> 00:29:45,000
So a connected acyclic graph
such that every vertex is part

362
00:29:45,000 --> 00:29:49,000
of the tree.
But it's got to have the

363
00:29:49,000 --> 00:29:55,000
minimum weight possible.
OK, so can somebody suggest to

364
00:29:55,000 --> 00:30:03,000
me some edges that have to be in
this minimum spanning tree?

365
00:30:03,000 --> 00:30:05,000
Yeah, so nine,
good.

366
00:30:05,000 --> 00:30:09,000
Nine has to be in there
because, why?

367
00:30:09,000 --> 00:30:14,000
It's the only one connecting it
to this vertex,

368
00:30:14,000 --> 00:30:16,000
OK?
And likewise,

369
00:30:16,000 --> 00:30:22,000
15 has to be in there.
So those both have to be in.

370
00:30:22,000 --> 00:30:26,000
What other edges have to be in?
Which one?

371
00:30:26,000 --> 00:30:33,000
14 has to be it.
Why does 14 have to be in?

372
00:30:33,000 --> 00:30:40,000
Well, one of 14 and three has
to be in there.

373
00:30:40,000 --> 00:30:50,000
I want the minimum weight.
The one that has the overall

374
00:30:50,000 --> 00:30:57,000
smallest weight.
So, can somebody argue to me

375
00:30:57,000 --> 00:31:04,000
that three has to be in there?
Yeah?

376
00:31:04,000 --> 00:31:09,000
That's the minimum of two,
which means that if I had a,

377
00:31:09,000 --> 00:31:14,000
if you add something you said
was a minimum spanning tree that

378
00:31:14,000 --> 00:31:19,000
didn't include three,
right, and so therefore it had

379
00:31:19,000 --> 00:31:23,000
to include 14,
then I could just delete this

380
00:31:23,000 --> 00:31:28,000
edge, 14, and put in edge three.
And, I have something of lower

381
00:31:28,000 --> 00:31:34,000
weight, right?
So, three has to be in there.

382
00:31:34,000 --> 00:31:37,000
What other edges have to be in
there?

383
00:31:37,000 --> 00:31:43,000
Do a little puzzle logic.
Six and five have to be in

384
00:31:43,000 --> 00:31:46,000
there.
Why do they have to be in

385
00:31:46,000 --> 00:31:48,000
there?

386
00:31:48,000 --> 00:32:02,000


387
00:32:02,000 --> 00:32:05,000
Yeah, well, I mean,
it could be connected through

388
00:32:05,000 --> 00:32:08,000
this or something.
It doesn't necessarily have to

389
00:32:08,000 --> 00:32:11,000
go this way.
Six definitely has to be in

390
00:32:11,000 --> 00:32:14,000
there for the same reason that
three had to be,

391
00:32:14,000 --> 00:32:16,000
right?
Because we got two choices to

392
00:32:16,000 --> 00:32:19,000
connect up this guy.
And so, if everything were

393
00:32:19,000 --> 00:32:22,000
connected but it weren't,
12, I mean, and 12 was in

394
00:32:22,000 --> 00:32:24,000
there.
I could always,

395
00:32:24,000 --> 00:32:27,000
then, say, well,
let's connect them up this way

396
00:32:27,000 --> 00:32:31,000
instead.
OK, so definitely that's in

397
00:32:31,000 --> 00:32:35,000
there.
I still don't have everything

398
00:32:35,000 --> 00:32:37,000
connected up.

399
00:32:37,000 --> 00:32:50,000


400
00:32:50,000 --> 00:33:03,000
What else has to be in there
for minimum spanning tree?

401
00:33:03,000 --> 00:33:11,000
Seven, five,
and eight, why seven,

402
00:33:11,000 --> 00:33:22,000
five, and eight?
OK, so can we argue those one

403
00:33:22,000 --> 00:33:32,000
at a time?
Why does five have to be in

404
00:33:32,000 --> 00:33:37,000
there?
Yeah?

405
00:33:37,000 --> 00:33:41,000
OK, so we have four connected
components because we have this

406
00:33:41,000 --> 00:33:43,000
one, this one,
we actually have,

407
00:33:43,000 --> 00:33:46,000
yeah, this one here,
and this one,

408
00:33:46,000 --> 00:33:49,000
good.
We need at least three edges to

409
00:33:49,000 --> 00:33:53,000
connect them because each edge
is going to reduce the connected

410
00:33:53,000 --> 00:33:57,000
components by one.
OK, so we need three edges,

411
00:33:57,000 --> 00:33:59,000
and those are the three
cheapest ones.

412
00:33:59,000 --> 00:34:04,000
And they work.
That works, right?

413
00:34:04,000 --> 00:34:11,000
Any other edges are going to be
bigger, so that works.

414
00:34:11,000 --> 00:34:15,000
Good.
OK, and so, now do we have a

415
00:34:15,000 --> 00:34:19,000
spanning tree?
Everything is,

416
00:34:19,000 --> 00:34:24,000
we have one big connected graph
here, right?

417
00:34:24,000 --> 00:34:31,000
Is that what I got?
Hey, that's the same as what I

418
00:34:31,000 --> 00:34:35,000
got.
Life is predictable.

419
00:34:35,000 --> 00:34:41,000
OK, so, so everybody had the
idea of what a minimum spanning

420
00:34:41,000 --> 00:34:44,000
tree is, then,
out of this,

421
00:34:44,000 --> 00:34:49,000
OK, what's going on there?
So, let's first of all make

422
00:34:49,000 --> 00:34:53,000
some observations about this
puzzle.

423
00:34:53,000 --> 00:34:59,000
And what I want to do is remind
you about the optimal

424
00:34:59,000 --> 00:35:06,000
substructure property because it
turns out minimum spanning tree

425
00:35:06,000 --> 00:35:12,000
has a great optimal substructure
property.

426
00:35:12,000 --> 00:35:17,000
OK, so the setup is going to
be, we're going to have some

427
00:35:17,000 --> 00:35:22,000
minimum spanning tree.
Let's call it T.

428
00:35:22,000 --> 00:35:27,000
And, I'm going to show that
with the other edges in the

429
00:35:27,000 --> 00:35:32,000
graph, are not going to be
shown.

430
00:35:32,000 --> 00:35:37,000
OK, so here's a graph.

431
00:35:37,000 --> 00:35:54,000


432
00:35:54,000 --> 00:35:58,000
OK, so here's a graph.
It looks like the one I have my

433
00:35:58,000 --> 00:36:01,000
piece of paper here.
OK, so the idea is,

434
00:36:01,000 --> 00:36:05,000
this is some minimum spanning
tree.

435
00:36:05,000 --> 00:36:09,000
Now, we want to look at a
property of optimal

436
00:36:09,000 --> 00:36:13,000
substructure.
And the way I'm going to get

437
00:36:13,000 --> 00:36:17,000
that, is, I'm going to remove
some edge, (u,v),

438
00:36:17,000 --> 00:36:22,000
move an arbitrary edge,
(u,v), in the minimum spanning

439
00:36:22,000 --> 00:36:26,000
tree.
So, let's call this u and this

440
00:36:26,000 --> 00:36:29,000
V.
And so, we're removing this

441
00:36:29,000 --> 00:36:33,000
edge.
OK, so when I remove an edge in

442
00:36:33,000 --> 00:36:36,000
a tree, what happens to the
tree?

443
00:36:36,000 --> 00:36:39,000
What's left?
I have two trees left,

444
00:36:39,000 --> 00:36:41,000
OK?
I have two trees left.

445
00:36:41,000 --> 00:36:45,000
Now, proving that,
that's basically one of the

446
00:36:45,000 --> 00:36:50,000
properties in that appendix,
and the properties of trees

447
00:36:50,000 --> 00:36:55,000
that I want you to read,
OK, because you can actually

448
00:36:55,000 --> 00:37:00,000
prove that kind of thing rather
than it just being obvious,

449
00:37:00,000 --> 00:37:05,000
which is, OK?
OK, so we remove that.

450
00:37:05,000 --> 00:37:11,000
Then, T is partitioned into two
subtrees.

451
00:37:11,000 --> 00:37:15,000
And, we'll call them T_1 and
T_2.

452
00:37:15,000 --> 00:37:22,000
So, here's one subtree,
and here's another subtree.

453
00:37:22,000 --> 00:37:29,000
We'(V,E) partitioned it.
No matter what edge I picked,

454
00:37:29,000 --> 00:37:38,000
there would be two subtrees
that it's partitioned into.

455
00:37:38,000 --> 00:37:40,000
Even if the sub tree is a
trivial subtree,

456
00:37:40,000 --> 00:37:43,000
for example,
it just has a single node in it

457
00:37:43,000 --> 00:37:45,000
and no edges.

458
00:37:45,000 --> 00:37:58,000


459
00:37:58,000 --> 00:38:11,000
So, the theorem that we'll
prove demonstrates a property of

460
00:38:11,000 --> 00:38:24,000
optimal substructure.
T_1 is a minimum spanning tree

461
00:38:24,000 --> 00:38:31,000
for the graph,
G_1, E_1,

462
00:38:31,000 --> 00:38:43,000
a subgraph of G induced by the
vertices in T_1.

463
00:38:43,000 --> 00:38:55,000
OK, that is,
V_1 is just the vertices in T_1

464
00:38:55,000 --> 00:39:09,000
is what it means to be induced.
OK, so V_1 is the vertices in

465
00:39:09,000 --> 00:39:12,000
T_1.
So, in this picture,

466
00:39:12,000 --> 00:39:16,000
I didn't label it.
This is T_1.

467
00:39:16,000 --> 00:39:20,000
This is T_2.
In this picture,

468
00:39:20,000 --> 00:39:27,000
these are the vertices of T_1.
So, that's V_1,

469
00:39:27,000 --> 00:39:32,000
OK?
And, E_1 is the set of pairs of

470
00:39:32,000 --> 00:39:39,000
vertices, x and y,
that are the edges that are in

471
00:39:39,000 --> 00:39:47,000
E_1 such that both x and y
belong to V_1.

472
00:39:47,000 --> 00:39:49,000
OK, so I haven't shown the
edges of G here.

473
00:39:49,000 --> 00:39:52,000
But basically,
if an edge went from here to

474
00:39:52,000 --> 00:39:57,000
here, that would be in the E_1.
If it went from here to here,

475
00:39:57,000 --> 00:40:00,000
it would not.
And if it went from here to

476
00:40:00,000 --> 00:40:04,000
here, it would not.
OK, so the vertices,

477
00:40:04,000 --> 00:40:10,000
the subgraph induced by the
vertices of T_1 are just those

478
00:40:10,000 --> 00:40:17,000
that connect up things in T_1,
and similarly for T_2.

479
00:40:17,000 --> 00:40:27,000


480
00:40:27,000 --> 00:40:33,000
So, the theorem says that if I
look at just the edges within

481
00:40:33,000 --> 00:40:38,000
the graph here,
G_1, those that are induced by

482
00:40:38,000 --> 00:40:41,000
these vertices,
T_1 is, in fact,

483
00:40:41,000 --> 00:40:46,000
a minimum spanning tree for
that subgraph.

484
00:40:46,000 --> 00:40:51,000
That's what the theorem says.
OK, if I look over here

485
00:40:51,000 --> 00:40:58,000
conversely, or correspondingly,
if I look at the set of edges

486
00:40:58,000 --> 00:41:05,000
that are induced by this set of
vertices, the vertices in T_2,

487
00:41:05,000 --> 00:41:13,000
in fact, T_2 is a minimum
spanning tree on that subgraph.

488
00:41:13,000 --> 00:41:17,000
OK, OK, we can even do it over
here.

489
00:41:17,000 --> 00:41:21,000
If I took a look,
for example,

490
00:41:21,000 --> 00:41:27,000
at these, let's see,
let's say we cut out five,

491
00:41:27,000 --> 00:41:35,000
and if I cut out edge five,
that T_1 would be these four

492
00:41:35,000 --> 00:41:40,000
vertices here.
And, the point is that if I

493
00:41:40,000 --> 00:41:44,000
look at the subgraph induced on
that, that these edges here.

494
00:41:44,000 --> 00:41:48,000
In fact, the six,
eight, and three are all edges

495
00:41:48,000 --> 00:41:52,000
in a minimum spanning tree for
that subgraph.

496
00:41:52,000 --> 00:41:54,000
OK, so that's what the theorem
says.

497
00:41:54,000 --> 00:41:57,000
So let's prove it.

498
00:41:57,000 --> 00:42:09,000


499
00:42:09,000 --> 00:42:19,000
OK, and so what technique are
we going to use to prove it?

500
00:42:19,000 --> 00:42:28,000
OK, we learned this technique
last time: hint,

501
00:42:28,000 --> 00:42:33,000
hint.
It's something you do it in

502
00:42:33,000 --> 00:42:39,000
your text editor all the time:
cut and paste,

503
00:42:39,000 --> 00:42:45,000
good, cut and paste.
OK, so the weight of T I can

504
00:42:45,000 --> 00:42:51,000
express as the weight of the
edge I removed,

505
00:42:51,000 --> 00:42:57,000
plus the weight of T_1,
plus the weight of T_2.

506
00:42:57,000 --> 00:43:07,000
OK, so that's the total weight.
So, the argument is pretty

507
00:43:07,000 --> 00:43:13,000
simple.
Suppose that there were some

508
00:43:13,000 --> 00:43:20,000
T_1 prime that was better than
T_1 for G_1.

509
00:43:20,000 --> 00:43:31,000
Suppose I had some better way
of forming a spanning tree.

510
00:43:31,000 --> 00:43:42,000
OK, then I would make up a T
prime, which just contained the

511
00:43:42,000 --> 00:43:48,000
edges, (u,v),
and T_1 prime,

512
00:43:48,000 --> 00:43:53,000
union T_2.
So, I would take,

513
00:43:53,000 --> 00:44:05,000
if I had a better spanning
tree, a spanning tree of lower

514
00:44:05,000 --> 00:44:12,000
weight for T_1.
And I call that T_1 prime.

515
00:44:12,000 --> 00:44:17,000
I just substitute that and make
up a spanning tree that

516
00:44:17,000 --> 00:44:22,000
consisted of my edge,
(u,v), whatever works well for

517
00:44:22,000 --> 00:44:26,000
T_1 prime and whatever works
well for T.

518
00:44:26,000 --> 00:44:30,000
And, that would be a spanning
tree.

519
00:44:30,000 --> 00:44:36,000
And it would be better than T
itself was for G,

520
00:44:36,000 --> 00:44:44,000
OK, because the weight of these
is just as the weight for this,

521
00:44:44,000 --> 00:44:50,000
I now just get to use the
weight of T_1 prime,

522
00:44:50,000 --> 00:44:54,000
and that's less.
And so, therefore,

523
00:44:54,000 --> 00:45:02,000
the assumption that T was a
minimum spanning tree would be

524
00:45:02,000 --> 00:45:11,000
violated if I could find a
better one for the subpiece.

525
00:45:11,000 --> 00:45:16,000
So, we have this nice property
of optimal substructure.

526
00:45:16,000 --> 00:45:20,000
OK, I have subproblems that
exhibit optimal,

527
00:45:20,000 --> 00:45:25,000
if I have a globally optimal
solution to the whole problem

528
00:45:25,000 --> 00:45:31,000
within it, I can find optimal
solutions to subproblems.

529
00:45:31,000 --> 00:45:36,000
So, now the question is,
that's one hallmark.

530
00:45:36,000 --> 00:45:41,000
That's one hallmark of dynamic
programming.

531
00:45:41,000 --> 00:45:45,000
What about overlapping
subproblems?

532
00:45:45,000 --> 00:45:51,000
Do I have that property?
Do I have overlapping

533
00:45:51,000 --> 00:45:58,000
subproblems over here for this
type of problem?

534
00:45:58,000 --> 00:46:19,000


535
00:46:19,000 --> 00:46:20,000
So, imagine,
for example,

536
00:46:20,000 --> 00:46:22,000
that I'm removing different
edges.

537
00:46:22,000 --> 00:46:26,000
I look at the space of taking a
given edge, and removing it.

538
00:46:26,000 --> 00:46:30,000
It partitions it into two
pieces, and now I have another

539
00:46:30,000 --> 00:46:32,000
piece.
And I remove it,

540
00:46:32,000 --> 00:46:35,000
etc.
Am I going to end up getting a

541
00:46:35,000 --> 00:46:38,000
bunch of subproblems that are
similar in there?

542
00:46:38,000 --> 00:46:41,000
Yeah, I am.
OK, if I take out this one,

543
00:46:41,000 --> 00:46:43,000
then I take out,
say, this one here,

544
00:46:43,000 --> 00:46:46,000
and then I'll have another tree
here and here.

545
00:46:46,000 --> 00:46:51,000
OK, that would be the same as
if I had originally taken this

546
00:46:51,000 --> 00:46:53,000
out, and then taken that one
out.

547
00:46:53,000 --> 00:46:57,000
If I look at simple ordering of
taking out the edges,

548
00:46:57,000 --> 00:47:00,000
I'm going to end up with a
whole bunch of overlapping

549
00:47:00,000 --> 00:47:04,000
subproblems.
Yeah, OK.

550
00:47:04,000 --> 00:47:14,000
So then, what does that suggest
we use as an approach?

551
00:47:14,000 --> 00:47:18,000
Dynamic programming,
good.

552
00:47:18,000 --> 00:47:26,000
What a surprise!
Yes, OK, you could use dynamic

553
00:47:26,000 --> 00:47:33,000
programming.
But it turns out that minimum

554
00:47:33,000 --> 00:47:41,000
spanning tree exhibits an even
more powerful property.

555
00:47:41,000 --> 00:47:48,000
OK, so we'(V,E) got all the
clues for dynamic programming,

556
00:47:48,000 --> 00:47:57,000
but it turns out that there's
an even bigger clue that's going

557
00:47:57,000 --> 00:48:05,000
to help us to use an even more
powerful technique.

558
00:48:05,000 --> 00:48:11,000
And that, we call,
the hallmark for greedy

559
00:48:11,000 --> 00:48:13,000
algorithms.

560
00:48:13,000 --> 00:48:32,000


561
00:48:32,000 --> 00:48:41,000
And that is,
we have a thing called the

562
00:48:41,000 --> 00:48:53,000
greedy choice property,
which says that a locally

563
00:48:53,000 --> 00:49:03,000
optimal choice is globally
optimal.

564
00:49:03,000 --> 00:49:05,000
And, of course,
as all these hallmarks is the

565
00:49:05,000 --> 00:49:09,000
kind of thing you want to box,
OK, because these are the clues

566
00:49:09,000 --> 00:49:12,000
that you're going to be able to
do that.

567
00:49:12,000 --> 00:49:15,000
So, we have this property that
we call the greedy choice

568
00:49:15,000 --> 00:49:18,000
property.
I'm going to show you how it

569
00:49:18,000 --> 00:49:21,000
works in this case.
And when you have a greedy

570
00:49:21,000 --> 00:49:24,000
choice property,
it turns out you can do even

571
00:49:24,000 --> 00:49:29,000
better that dynamic programming.
OK, so when you see the two

572
00:49:29,000 --> 00:49:33,000
dynamic programming properties,
there is a clue that says

573
00:49:33,000 --> 00:49:36,000
dynamic programming,
yes, but also it says,

574
00:49:36,000 --> 00:49:41,000
let me see whether it also has
this greedy property because if

575
00:49:41,000 --> 00:49:46,000
it does, you're going to come up
with something that's even

576
00:49:46,000 --> 00:49:49,000
better than dynamic programming,
OK?

577
00:49:49,000 --> 00:49:53,000
So, if you just have the two,
you can usually do dynamic

578
00:49:53,000 --> 00:49:56,000
programming, but if you have
this third one,

579
00:49:56,000 --> 00:50:00,000
it's like, whoa!
Jackpot!

580
00:50:00,000 --> 00:50:04,000
OK, so here's the theorem we'll
prove to illustrate this idea.

581
00:50:04,000 --> 00:50:08,000
Once again, these are not,
all these hallmarks are not

582
00:50:08,000 --> 00:50:09,000
things.
They are heuristics.

583
00:50:09,000 --> 00:50:14,000
I can't give you an algorithm
to say, here's where dynamic

584
00:50:14,000 --> 00:50:16,000
programming works,
or here's where greedy

585
00:50:16,000 --> 00:50:20,000
algorithms work.
But I can sort of indicate when

586
00:50:20,000 --> 00:50:23,000
they work, the kind of structure
they have.

587
00:50:23,000 --> 00:50:32,000
OK, so here's the theorem.
So let's let T be the MST of

588
00:50:32,000 --> 00:50:40,000
our graph.
And, let's let A be any subset

589
00:50:40,000 --> 00:50:49,000
of V, so, some subset of
vertices.

590
00:50:49,000 --> 00:51:04,000
And now, let's suppose that
edge, (u,v), is the least weight

591
00:51:04,000 --> 00:51:17,000
edge connecting our set A to A
complement, that is,

592
00:51:17,000 --> 00:51:27,000
V minus A.
Then the theorem says that

593
00:51:27,000 --> 00:51:39,000
(u,v) is in the minimum spanning
tree.

594
00:51:39,000 --> 00:51:43,000
So let's just take a look at
our graph over here and see if

595
00:51:43,000 --> 00:51:45,000
that's, in fact,
the case.

596
00:51:45,000 --> 00:51:49,000
OK, so let's take,
so one thing I could do for A

597
00:51:49,000 --> 00:51:53,000
is just take a singleton node.
So, I take a singleton node,

598
00:51:53,000 --> 00:51:56,000
let's say this guy here,
that can be my A,

599
00:51:56,000 --> 00:52:00,000
and everything else is V minus
A.

600
00:52:00,000 --> 00:52:04,000
And I look at the least weight
edge connecting this to

601
00:52:04,000 --> 00:52:07,000
everything else.
Well, there are only two edges

602
00:52:07,000 --> 00:52:10,000
that connect it to everything
else.

603
00:52:10,000 --> 00:52:15,000
And the theorem says that the
lighter one is in the minimum

604
00:52:15,000 --> 00:52:17,000
spanning tree.
Hey, I win.

605
00:52:17,000 --> 00:52:21,000
OK, if you take a look,
every vertex that I pick,

606
00:52:21,000 --> 00:52:25,000
the latest edge coming out of
that vertex is in the minimum

607
00:52:25,000 --> 00:52:29,000
spanning tree.
OK, the lightest weight edge

608
00:52:29,000 --> 00:52:35,000
coming out, but that's not all
the edges that are in here.

609
00:52:35,000 --> 00:52:39,000
OK, or let's just imagine,
let's take a look at these

610
00:52:39,000 --> 00:52:43,000
three vertices connected to this
set of vertices.

611
00:52:43,000 --> 00:52:46,000
I have three edges is going
across.

612
00:52:46,000 --> 00:52:50,000
The least weight one is five.
That's the minimum spanning

613
00:52:50,000 --> 00:52:53,000
tree.
Or, I can cut it this way.

614
00:52:53,000 --> 00:52:57,000
OK, the ones above one,
the edges going down are seven,

615
00:52:57,000 --> 00:53:02,000
eight, and 14.
Seven is the least weight.

616
00:53:02,000 --> 00:53:04,000
It's in the minimum spanning
tree.

617
00:53:04,000 --> 00:53:08,000
So, no matter how I choose,
I could make this one in,

618
00:53:08,000 --> 00:53:10,000
this one out,
this one in,

619
00:53:10,000 --> 00:53:12,000
this one out,
this one in,

620
00:53:12,000 --> 00:53:14,000
this one out,
this one in,

621
00:53:14,000 --> 00:53:18,000
this one out,
take a look at what all the

622
00:53:18,000 --> 00:53:21,000
edges are.
Which ever one to the least

623
00:53:21,000 --> 00:53:24,000
weight: it's in the minimum
spanning tree.

624
00:53:24,000 --> 00:53:28,000
So, in some sense,
that's a local property because

625
00:53:28,000 --> 00:53:34,000
I don't have to look at what the
rest of the tree is.

626
00:53:34,000 --> 00:53:38,000
I'm just looking at some small
set of vertices if I wish,

627
00:53:38,000 --> 00:53:42,000
and I say, well,
if I wanted to connect that set

628
00:53:42,000 --> 00:53:46,000
of vertices to the rest of the
world, what would I pick?

629
00:53:46,000 --> 00:53:50,000
I'd pick the cheapest one.
That's the greedy approach.

630
00:53:50,000 --> 00:53:53,000
It turns out,
that wins, OK,

631
00:53:53,000 --> 00:53:57,000
that picking that thing that's
locally good for that subset,

632
00:53:57,000 --> 00:54:04,000
A, OK, is also globally good.
OK, it optimizes the overall

633
00:54:04,000 --> 00:54:09,000
function.
That's what the theorem says,

634
00:54:09,000 --> 00:54:13,000
OK?
So, let's prove this theorem.

635
00:54:13,000 --> 00:54:20,000
Any questions about this?
OK, let's prove this theorem.

636
00:54:20,000 --> 00:54:27,000
So, we have (u,v) is the least
weight edge connecting A to D

637
00:54:27,000 --> 00:54:32,000
minus A.
So, let's suppose that this

638
00:54:32,000 --> 00:54:40,000
edge, (u,v), is not in the
minimum spanning tree.

639
00:54:40,000 --> 00:54:45,000
OK, let's suppose that somehow
there is a minimum spanning tree

640
00:54:45,000 --> 00:54:50,000
that doesn't include this least
weight edge.

641
00:54:50,000 --> 00:54:55,000
OK, so what technique you think
will use to prove to get a

642
00:54:55,000 --> 00:54:58,000
contradiction here?
Cut and paste,

643
00:54:58,000 --> 00:55:04,000
good.
Yeah, we're going to cut paste.

644
00:55:04,000 --> 00:55:08,000
OK, we're going to cut and
paste.

645
00:55:08,000 --> 00:55:14,000
So here, I did an example.
OK, so --

646
00:55:14,000 --> 00:55:40,000


647
00:55:40,000 --> 00:55:42,000
OK, and so I'm going to use the
notation.

648
00:55:42,000 --> 00:55:44,000
I'm going to color some of
these in.

649
00:55:44,000 --> 00:56:05,000


650
00:56:05,000 --> 00:56:10,000
OK, and so my notation here is
this is an element of A,

651
00:56:10,000 --> 00:56:14,000
and color it in.
It's an element of V minus A.

652
00:56:14,000 --> 00:56:18,000
OK, so if it's not colored it,
that's an A.

653
00:56:18,000 --> 00:56:21,000
This is my minimum spanning
tree.

654
00:56:21,000 --> 00:56:27,000
Once again, I'm not showing the
overall edges of all the graphs,

655
00:56:27,000 --> 00:56:30,000
but they're there,
OK?

656
00:56:30,000 --> 00:56:33,000
So, my edge,
(u,v), which is not my minimum

657
00:56:33,000 --> 00:56:38,000
spanning tree I say,
let's say is this edge here.

658
00:56:38,000 --> 00:56:42,000
It's an edge from u,
u as in A, v as in V minus A.

659
00:56:42,000 --> 00:56:48,000
OK, so everybody see the setup?
So, I want to prove that this

660
00:56:48,000 --> 00:56:52,000
edge should have been in the
minimum spanning tree,

661
00:56:52,000 --> 00:56:58,000
OK, that the contention that
this is a minimum spanning tree,

662
00:56:58,000 --> 00:57:02,000
and does include (u,v) is
wrong.

663
00:57:02,000 --> 00:57:05,000
So, what I want to do,
that, is I have a tree here,

664
00:57:05,000 --> 00:57:08,000
T, and I have two vertices,
u and v, and in a tree,

665
00:57:08,000 --> 00:57:12,000
between any two vertices there
is a unique, simple path:

666
00:57:12,000 --> 00:57:16,000
simple path meaning it doesn't
go back and forth and repeat

667
00:57:16,000 --> 00:57:18,000
edges or vertices.
OK, there's a unique,

668
00:57:18,000 --> 00:57:23,000
simple path from u to v.
So, let's consider that path.

669
00:57:23,000 --> 00:57:42,000


670
00:57:42,000 --> 00:57:46,000
OK, and the way that I know
that that path exists is because

671
00:57:46,000 --> 00:57:51,000
I'(V,E) read appendix B of the
textbook, section B.5.1,

672
00:57:51,000 --> 00:57:56,000
OK, which has this nice theorem
about properties of trees.

673
00:57:56,000 --> 00:58:00,000
OK, so that's how I know that
there exists a unique,

674
00:58:00,000 --> 00:58:05,000
simple path.
OK, so now we're going to do is

675
00:58:05,000 --> 00:58:09,000
take a look at that path.
So in this case,

676
00:58:09,000 --> 00:58:13,000
it goes from here,
to here, to here,

677
00:58:13,000 --> 00:58:16,000
to here.
And along that path,

678
00:58:16,000 --> 00:58:22,000
there must be a point where I
connect from a vertex in A to a

679
00:58:22,000 --> 00:58:25,000
vertex in V minus A.
Why?

680
00:58:25,000 --> 00:58:32,000
Well, because this is in A.
This is in V minus A.

681
00:58:32,000 --> 00:58:42,000
So, along the path somewhere,
there must be a transition.

682
00:58:42,000 --> 00:58:52,000
OK, they are not all in A,
OK, because in particular,

683
00:58:52,000 --> 00:58:58,000
V isn't.
OK, so we're going to do is

684
00:58:58,000 --> 00:59:09,000
swap (u,v) with the first edge
on this path that connects a

685
00:59:09,000 --> 00:59:18,000
vertex in A to a vertex in V
minus A.

686
00:59:18,000 --> 00:59:20,000
So in this case,
it's this edge here.

687
00:59:20,000 --> 00:59:24,000
I go from A to V minus A.
In general, I might be

688
00:59:24,000 --> 00:59:28,000
alternating many times,
OK, and I just picked the first

689
00:59:28,000 --> 00:59:32,000
one that I encounter.
OK, that this guy here.

690
00:59:32,000 --> 00:59:36,000
And what I do is I put this
edge in.

691
00:59:36,000 --> 00:59:38,000
OK, so then,
what happens?

692
00:59:38,000 --> 00:59:42,000
Well, the edge,
(u,v), is the lightest thing

693
00:59:42,000 --> 00:59:46,000
connecting something in A to
something in V minus A.

694
00:59:46,000 --> 00:59:49,000
So that means,
in particular,

695
00:59:49,000 --> 00:59:53,000
it's lighter than this edge,
has lower weight.

696
00:59:53,000 --> 00:59:57,000
So, by swapping this,
I'(V,E) created a tree with

697
00:59:57,000 --> 01:00:02,198
lower overall weight,
contradicting the assumption

698
01:00:02,198 --> 01:00:08,000
that this other thing was a
minimum spanning tree.

699
01:00:08,000 --> 01:00:14,219
OK: so, a lower weight spanning
tree than T results,

700
01:00:14,219 --> 01:00:18,000
and that's a contradiction --

701
01:00:18,000 --> 01:00:25,000


702
01:00:25,000 --> 01:00:33,010
-- than T results.
And that's a contradiction,

703
01:00:33,010 --> 01:00:36,570
OK?
How are we doing?

704
01:00:36,570 --> 01:00:44,225
Everybody with me?
OK, now we get to do some

705
01:00:44,225 --> 01:00:46,895
algorithms.
Yea!

706
01:00:46,895 --> 01:00:55,439
So, we are going to do an
algorithm called Prim's

707
01:00:55,439 --> 01:01:01,853
algorithm.
Prim eventually became a very

708
01:01:01,853 --> 01:01:07,069
high-up at AT&T because he
invented this algorithm for

709
01:01:07,069 --> 01:01:12,187
minimum spanning trees,
and it was used in all of the

710
01:01:12,187 --> 01:01:15,730
billing code for AT&T for many
years.

711
01:01:15,730 --> 01:01:21,438
He was very high up at Bell
Labs back in the heyday of Bell

712
01:01:21,438 --> 01:01:24,784
Laboratories.
OK, so it just shows,

713
01:01:24,784 --> 01:01:30,000
all you have to do is invent an
algorithm.

714
01:01:30,000 --> 01:01:36,702
You too can be a president of a
corporate monopoly.

715
01:01:36,702 --> 01:01:43,807
Of course, the government can
do things to monopolies,

716
01:01:43,807 --> 01:01:49,438
but anyway, if that's your
mission in life,

717
01:01:49,438 --> 01:01:55,202
invent an algorithm.
OK, so here's the idea.

718
01:01:55,202 --> 01:02:03,648
What we're going to do is we're
going to maintain V minus A as a

719
01:02:03,648 --> 01:02:11,923
priority queue.
We'll call it Q.

720
01:02:11,923 --> 01:02:26,076
And each vertex,
we're going to key each vertex

721
01:02:26,076 --> 01:02:39,923
in Q with the weight of the
least weight edge,

722
01:02:39,923 --> 01:02:53,280
connecting it to a vertex in A.
So here's the code.

723
01:02:53,280 --> 01:03:00,000
So, we're going to start out
with Q being all vertices.

724
01:03:00,000 --> 01:03:03,873
So, we start out with A being,
if you will,

725
01:03:03,873 --> 01:03:07,930
the empty set.
OK, and what we're going to do

726
01:03:07,930 --> 01:03:13,095
it is the least weight edge,
therefore, for everything in

727
01:03:13,095 --> 01:03:18,536
the priority queue is basically
going to be infinity because

728
01:03:18,536 --> 01:03:23,700
none of them have any edges.
The least weight edge to the

729
01:03:23,700 --> 01:03:29,325
empty set is going to be empty.
And then, we're going to start

730
01:03:29,325 --> 01:03:33,958
out with one guy.
We'll call him S,

731
01:03:33,958 --> 01:03:39,489
which will set to zero for some
arbitrary S in V.

732
01:03:39,489 --> 01:03:45,135
And then, the main part of the
algorithm kicks in.

733
01:03:45,135 --> 01:03:51,703
So that's our initialization.
OK, when we do the analysis,

734
01:03:51,703 --> 01:03:58,271
I'm going to write some stuff
on the left hand side of the

735
01:03:58,271 --> 01:04:04,406
board.
So if you're taking notes,

736
01:04:04,406 --> 01:04:14,406
you may want to also leave a
little bit of space on the left

737
01:04:14,406 --> 01:04:22,711
hand side of your notes.
So, while Q is not empty,

738
01:04:22,711 --> 01:04:30,000
we get the smallest element out
of it.

739
01:04:30,000 --> 01:04:41,000


740
01:04:41,000 --> 01:04:43,000
And then we do some stuff.

741
01:04:43,000 --> 01:05:19,000


742
01:05:19,000 --> 01:05:21,970
That's it.
And the only thing I should

743
01:05:21,970 --> 01:05:25,503
mention here is,
OK, so let's just see what's

744
01:05:25,503 --> 01:05:28,875
going on here.
And then we'll run it on the

745
01:05:28,875 --> 01:05:32,256
example.
OK, so what we do is we take

746
01:05:32,256 --> 01:05:36,609
out the smallest element out of
the queue at each step.

747
01:05:36,609 --> 01:05:40,156
And then for each step in the
adjacency list,

748
01:05:40,156 --> 01:05:43,783
in other words,
everything for which I have an

749
01:05:43,783 --> 01:05:46,846
edge going from v to u,
we take a look,

750
01:05:46,846 --> 01:05:51,440
and if v is still in our set V
minus A, so things we'(V,E)

751
01:05:51,440 --> 01:05:54,261
taken out are going to be part
of A.

752
01:05:54,261 --> 01:05:57,163
OK, every time we take
something out,

753
01:05:57,163 --> 01:06:02,000
that's going to be a new A that
we construct.

754
01:06:02,000 --> 01:06:04,258
At every step,
we want to find,

755
01:06:04,258 --> 01:06:08,400
what's the cheapest edge
connecting that A to everything

756
01:06:08,400 --> 01:06:11,035
else?
We basically are going to take

757
01:06:11,035 --> 01:06:15,025
whatever that cheapest thing is,
OK, add that edge in,

758
01:06:15,025 --> 01:06:19,242
and now bring that into A and
find the next cheapest one.

759
01:06:19,242 --> 01:06:22,103
And we just keep repeating the
process.

760
01:06:22,103 --> 01:06:25,567
OK, we'll do it on the example.
And what we do,

761
01:06:25,567 --> 01:06:28,955
is every time we bring it in,
I keep track of,

762
01:06:28,955 --> 01:06:34,000
what was the vertex responsible
for bringing me in.

763
01:06:34,000 --> 01:06:43,947
And what I claim is that at the
end, if I look at the set of

764
01:06:43,947 --> 01:06:52,209
these pairs that I'(V,E) made
here, V and pi of V,

765
01:06:52,209 --> 01:06:58,279
that forms the minimum spanning
tree.

766
01:06:58,279 --> 01:07:05,441
So let's just do this.
And, what's that?

767
01:07:05,441 --> 01:07:12,191
We're all set up.
So let's get rid of these guys

768
01:07:12,191 --> 01:07:20,234
here because we are going to
recompute them from scratch.

769
01:07:20,234 --> 01:07:30,000
OK, so you may want to copy the
graph over again in your notes.

770
01:07:30,000 --> 01:07:34,840
I was going to do it,
but it turned out,

771
01:07:34,840 --> 01:07:40,797
this is exactly the board is
going to erase this.

772
01:07:40,797 --> 01:07:47,127
OK, well let me just modify it.
OK, so we start out.

773
01:07:47,127 --> 01:07:54,574
We make everything be infinity.
OK, so that's where I'm going

774
01:07:54,574 --> 01:08:01,028
to keep the key value.
OK, and then what I'm going to

775
01:08:01,028 --> 01:08:07,952
do is find one vertex.
And I'm going to call him S.

776
01:08:07,952 --> 01:08:11,749
And I'm going to do this vertex
here.

777
01:08:11,749 --> 01:08:15,018
We'll call that S.
So basically,

778
01:08:15,018 --> 01:08:19,447
I now make him be zero.
And now, what I do,

779
01:08:19,447 --> 01:08:23,453
is I execute extract min.
So basically,

780
01:08:23,453 --> 01:08:28,198
what I'll do is I'll just shade
him like this,

781
01:08:28,198 --> 01:08:34,000
indicating that he has now
joined the set A.

782
01:08:34,000 --> 01:08:40,931
So, this is going to be A.
And this is element of V minus

783
01:08:40,931 --> 01:08:44,644
A.
OK, so then what we do is we

784
01:08:44,644 --> 01:08:47,986
take a look.
We extract him,

785
01:08:47,986 --> 01:08:53,433
and then for each edge in the
adjacency list,

786
01:08:53,433 --> 01:08:59,002
OK, so for each vertex in the
adjacency lists,

787
01:08:59,002 --> 01:09:05,315
that these guys here,
OK, we're going to look to see

788
01:09:05,315 --> 01:09:12,000
if it's still in Q,
that is, in V minus A.

789
01:09:12,000 --> 01:09:16,795
And if so, and its key value is
less than what the value is at

790
01:09:16,795 --> 01:09:20,254
the edge, there,
we're going to replace it by

791
01:09:20,254 --> 01:09:22,770
the edge value.
So, in this case,

792
01:09:22,770 --> 01:09:25,600
we're going to replace this by
seven.

793
01:09:25,600 --> 01:09:30,317
We're going to replace this by
15, and we're going to replace

794
01:09:30,317 --> 01:09:33,854
this by ten, OK,
because what we're interested

795
01:09:33,854 --> 01:09:39,608
in is, what is the cheapest?
Now, notice that everything in

796
01:09:39,608 --> 01:09:43,782
V minus A, that is,
what's in the priority queue,

797
01:09:43,782 --> 01:09:48,216
everything in there,
OK, now has its cheapest way of

798
01:09:48,216 --> 01:09:53,086
connecting it to the things that
I'(V,E) already removed,

799
01:09:53,086 --> 01:09:57,173
the things that are in A.
OK, and so now I just,

800
01:09:57,173 --> 01:10:01,608
OK, when I actually do that
update, there's actually

801
01:10:01,608 --> 01:10:07,000
something implicit going on in
this priority queue.

802
01:10:07,000 --> 01:10:10,636
And that is that I have to do a
decreased key.

803
01:10:10,636 --> 01:10:14,111
So, there's an implicit
decrease of the key.

804
01:10:14,111 --> 01:10:19,121
So, decreased key is a priority
queue operation that lowers the

805
01:10:19,121 --> 01:10:22,191
value of the key in the priority
queue.

806
01:10:22,191 --> 01:10:26,878
And so, that's implicitly going
on when I look at what data

807
01:10:26,878 --> 01:10:31,646
structure I'm going to use to
implement that priority queue.

808
01:10:31,646 --> 01:10:36,171
OK, so common data structures
for implementing a priority

809
01:10:36,171 --> 01:10:41,376
queue are a min heap.
OK, so I have to make sure that

810
01:10:41,376 --> 01:10:43,905
I'm actually doing this
operation.

811
01:10:43,905 --> 01:10:47,355
I can't just change it and not
affect my heap.

812
01:10:47,355 --> 01:10:51,111
So, there is an implicit
operation going on there.

813
01:10:51,111 --> 01:10:54,407
OK, now I repeat.
I find the cheapest thing,

814
01:10:54,407 --> 01:10:58,547
oh, and I also have to set,
now, a pointer from each of

815
01:10:58,547 --> 01:11:02,931
these guys back to u.
So here, this guy sets a

816
01:11:02,931 --> 01:11:07,114
pointer going this way.
This guy sets a pointer going

817
01:11:07,114 --> 01:11:11,298
this way, and this guy sets a
pointer going this way.

818
01:11:11,298 --> 01:11:16,206
That's my pi thing that's going
to keep track of who caused me

819
01:11:16,206 --> 01:11:20,873
to set my value to what it is.
So now, we go in and we find

820
01:11:20,873 --> 01:11:22,885
the cheapest thing,
again.

821
01:11:22,885 --> 01:11:25,620
And we're going to do it fast,
too.

822
01:11:25,620 --> 01:11:32,361
OK, this is a fast algorithm.
OK, so now we're going to go do

823
01:11:32,361 --> 01:11:36,481
this again.
So now, what's the cheapest

824
01:11:36,481 --> 01:11:39,843
thing to extract?
This guy here,

825
01:11:39,843 --> 01:11:42,987
right?
So, we'll take him out,

826
01:11:42,987 --> 01:11:47,542
OK, and now we update all of
his neighbors.

827
01:11:47,542 --> 01:11:51,771
So this guy gets five.
This guy gets 12.

828
01:11:51,771 --> 01:11:56,542
This guy gets nine.
This guy we don't update.

829
01:11:56,542 --> 01:12:02,722
We don't update him because
he's no longer in the priority

830
01:12:02,722 --> 01:12:07,464
queue.
And all of these guys now,

831
01:12:07,464 --> 01:12:12,297
we make point to where they're
supposed to point to.

832
01:12:12,297 --> 01:12:17,983
And, we're done with that step.
Now we find the cheapest one.

833
01:12:17,983 --> 01:12:22,437
What's the cheapest one now?
The five over here.

834
01:12:22,437 --> 01:12:24,807
Good.
So, we take him out.

835
01:12:24,807 --> 01:12:30,019
OK, we update the neighbors.
Here, yep, that goes to six

836
01:12:30,019 --> 01:12:34,000
now.
And, we have that pointer.

837
01:12:34,000 --> 01:12:39,684
And, this guy we don't do,
because he's not in there.

838
01:12:39,684 --> 01:12:44,604
This guy becomes 14,
and this guy here becomes

839
01:12:44,604 --> 01:12:47,774
eight.
So, we update that guy,

840
01:12:47,774 --> 01:12:52,803
make him be eight.
Did I do this the right way?

841
01:12:52,803 --> 01:12:57,395
Yeah, because pi is a function
of this guy.

842
01:12:57,395 --> 01:13:00,675
So basically,
this thing, then,

843
01:13:00,675 --> 01:13:04,938
disappears.
Yeah, did I have another one

844
01:13:04,938 --> 01:13:09,258
that I missed?
12, yes, good,

845
01:13:09,258 --> 01:13:12,584
it's removed,
OK, because pi is just a

846
01:13:12,584 --> 01:13:14,741
function.
And now I'm OK.

847
01:13:14,741 --> 01:13:18,516
OK, so now what do I do?
OK, so now my set,

848
01:13:18,516 --> 01:13:23,191
A, consists of these three
things, and now I want the

849
01:13:23,191 --> 01:13:26,786
cheapest edge.
I know it's in the minimum

850
01:13:26,786 --> 01:13:30,561
spanning tree.
So let me just greedily pick

851
01:13:30,561 --> 01:13:34,554
it.
OK, so what's the cheapest

852
01:13:34,554 --> 01:13:37,108
thing now?
This guy appear?

853
01:13:37,108 --> 01:13:39,466
Yeah, six.
So we take it.

854
01:13:39,466 --> 01:13:44,771
We go to update these things,
and nothing matters here.

855
01:13:44,771 --> 01:13:50,175
OK, nothing changes because
these guys are already in A.

856
01:13:50,175 --> 01:13:54,202
OK, so now the cheapest one is
eight here.

857
01:13:54,202 --> 01:13:56,856
Good.
So, we take eight out.

858
01:13:56,856 --> 01:14:01,656
OK, we update this.
Nothing to be done.

859
01:14:01,656 --> 01:14:04,970
This: nothing to be done.
This: oh, no,

860
01:14:04,970 --> 01:14:09,242
this one, instead of 14 we can
make this be three.

861
01:14:09,242 --> 01:14:14,212
So, we get rid of that pointer
and make it point that way.

862
01:14:14,212 --> 01:14:16,915
Now three is the cheapest
thing.

863
01:14:16,915 --> 01:14:21,100
So, we take it out,
and of course there's nothing

864
01:14:21,100 --> 01:14:24,239
to be done over there.
And now, last,

865
01:14:24,239 --> 01:14:26,506
I take nine.
And it's done.

866
01:14:26,506 --> 01:14:32,000
And 15: it's done.
And the algorithm terminates.

867
01:14:32,000 --> 01:14:36,972
OK, and as I look at,
now, all the edges that I

868
01:14:36,972 --> 01:14:43,135
picked, those are exactly all
the edges that we had at the

869
01:14:43,135 --> 01:14:48,000
beginning.
OK, let's do an analysis here.

870
01:14:48,000 --> 01:14:58,000


871
01:14:58,000 --> 01:15:06,316
OK, so let's see,
this part here costs me order

872
01:15:06,316 --> 01:15:11,197
V, right?
OK, and this part,

873
01:15:11,197 --> 01:15:16,983
let's see what we are doing
here.

874
01:15:16,983 --> 01:15:27,107
Well, we're going to go through
this loop how many times?

875
01:15:27,107 --> 01:15:32,711
V times.
It's V elements we put into the

876
01:15:32,711 --> 01:15:35,860
queue.
We are not inserting anything.

877
01:15:35,860 --> 01:15:39,795
We're just taking them out.
This goes V times,

878
01:15:39,795 --> 01:15:43,818
OK, and we do a certain number
of extract Mins.

879
01:15:43,818 --> 01:15:47,492
So, we're going to do order V
extract Mins.

880
01:15:47,492 --> 01:15:52,915
And then we go to the adjacency
list, and we have some constant

881
01:15:52,915 --> 01:15:55,801
things.
But we have these implicit

882
01:15:55,801 --> 01:16:00,000
decreased keys for this stuff
here.

883
01:16:00,000 --> 01:16:07,412
That's this thing here.
OK, and so how many implicit

884
01:16:07,412 --> 01:16:14,389
decreased keys do we have?
That's going to be the

885
01:16:14,389 --> 01:16:18,459
expensive thing.
OK, we have,

886
01:16:18,459 --> 01:16:25,000
in this case,
the degree of u of those.

887
01:16:25,000 --> 01:16:31,309
OK, so overall,
how many implicit decreased

888
01:16:31,309 --> 01:16:38,218
keys do we have?
Well, we have V times through.

889
01:16:38,218 --> 01:16:43,025
How big could the degree of u
be?

890
01:16:43,025 --> 01:16:48,433
OK, it could be as big as V,
order V.

891
01:16:48,433 --> 01:16:56,995
So, that's V^2 decreased use.
But we can do a better bound

892
01:16:56,995 --> 01:17:04,189
than that.
How many do we really have?

893
01:17:04,189 --> 01:17:11,948
Yeah, at most order E,
OK, because what am I doing?

894
01:17:11,948 --> 01:17:19,086
I'm summing up the degrees of
all the vertices.

895
01:17:19,086 --> 01:17:27,000
That's how many times I
actually execute that.

896
01:17:27,000 --> 01:17:34,322
So, I have order E,
implicit decreased keys.

897
01:17:34,322 --> 01:17:44,028
So the time overall is order V
times time for whatever the

898
01:17:44,028 --> 01:17:53,224
extract Min is plus E times the
time for decreased key.

899
01:17:53,224 --> 01:18:02,931
So now, let's look at data
structures, and we can evaluate

900
01:18:02,931 --> 01:18:14,000
for different data structures
what this formula gives us.

901
01:18:14,000 --> 01:18:21,492
So, we have different ways of
implementing a data structure.

902
01:18:21,492 --> 01:18:28,222
We have the cost of extract
Min, and of decreased key,

903
01:18:28,222 --> 01:18:32,636
and total.
So, the simplest way of

904
01:18:32,636 --> 01:18:38,369
implementing a data structure is
an unsorted array.

905
01:18:38,369 --> 01:18:44,904
If I have an unsorted array,
how much time does it take me

906
01:18:44,904 --> 01:18:51,668
to extract the minimum element?
If I have an unsorted array?

907
01:18:51,668 --> 01:18:58,433
Right, order V in this case
because it's an array of size V.

908
01:18:58,433 --> 01:19:06,000
And, to do a decreased key,
OK, I can do it in order one.

909
01:19:06,000 --> 01:19:14,245
So, the total is V^2,
good, order V^2 algorithm.

910
01:19:14,245 --> 01:19:22,666
Or, as people suggested,
how about a binary heap?

911
01:19:22,666 --> 01:19:33,017
OK, to do an extract Min in a
binary heap will cost me what?

912
01:19:33,017 --> 01:19:38,905
O of log V.
Decreased key will cost me,

913
01:19:38,905 --> 01:19:44,932
yeah, it turns out you can do
that in order log V because

914
01:19:44,932 --> 01:19:49,668
basically you just have to
shuffle the value,

915
01:19:49,668 --> 01:19:54,295
actually shuffle it up towards
the root, OK?

916
01:19:54,295 --> 01:19:58,708
Or at log V.
And, the total cost therefore

917
01:19:58,708 --> 01:20:01,717
is?
E log V, good.

918
01:20:01,717 --> 01:20:06,869
Which of these is better?
It depends, good.

919
01:20:06,869 --> 01:20:12,758
When is one better,
and when is the other better?

920
01:20:12,758 --> 01:20:18,401
Yeah, if it's a dense graph,
E is close to V^2,

921
01:20:18,401 --> 01:20:24,166
the array is better.
But if it's a sparse graph,

922
01:20:24,166 --> 01:20:33,000
and E is much smaller than V^2,
then the binary heap is better.

923
01:20:33,000 --> 01:20:37,824
So that motivated the invention
of a data structure,

924
01:20:37,824 --> 01:20:43,216
OK, called a Fibonacci Heap.
So, Fibonacci Heap is covered

925
01:20:43,216 --> 01:20:47,851
in Chapter 20 of CLRS.
We're not going to hold you

926
01:20:47,851 --> 01:20:53,148
responsible for the content,
but it's an interesting data

927
01:20:53,148 --> 01:20:57,878
structure because it's an
amortized data structure.

928
01:20:57,878 --> 01:21:01,851
And it turns out that it is
data structure,

929
01:21:01,851 --> 01:21:08,000
you can do extract Min in order
log V amortized time.

930
01:21:08,000 --> 01:21:12,747
And remarkably,
you can do decreased key in

931
01:21:12,747 --> 01:21:17,834
order one amortized.
So, when I plug those in,

932
01:21:17,834 --> 01:21:21,000
what do I get over here?

933
01:21:21,000 --> 01:21:34,000


934
01:21:34,000 --> 01:21:42,088
What's that going to be?
Plug that it here.

935
01:21:42,088 --> 01:21:52,296
It's going to be V times log V
plus E: E plus V log V.

936
01:21:52,296 --> 01:22:00,000
These are amortized,
so what's this?

937
01:22:00,000 --> 01:22:02,317
Trick question.
It's worst-case.

938
01:22:02,317 --> 01:22:05,979
It's not amortized over here.
These are amortized,

939
01:22:05,979 --> 01:22:08,745
but that's the beauty of
amortization.

940
01:22:08,745 --> 01:22:13,006
I can say it's going to be
worst case: E plus V log V over

941
01:22:13,006 --> 01:22:17,715
here, because when I add up the
amortized cost of my operations,

942
01:22:17,715 --> 01:22:20,480
it's an upper bound on the true
costs.

943
01:22:20,480 --> 01:22:24,291
OK, so that's why I say,
one of the beauties of this

944
01:22:24,291 --> 01:22:27,058
amortized analysis,
and in particular,

945
01:22:27,058 --> 01:22:31,692
being able to assign different
costs to different operations is

946
01:22:31,692 --> 01:22:37,000
I can just add them up and I get
my worst-case costs.

947
01:22:37,000 --> 01:22:40,565
So this is already V log V.
There are a couple other

948
01:22:40,565 --> 01:22:43,012
algorithms just before I let you
go.

949
01:22:43,012 --> 01:22:47,066
Kruskal's Algorithm in the book
uses another amortized data

950
01:22:47,066 --> 01:22:50,282
structure called a disjoint set
data structure,

951
01:22:50,282 --> 01:22:53,498
which also runs in E log V,
that is, this time:

952
01:22:53,498 --> 01:22:56,574
runs in this time,
the same as using a binary

953
01:22:56,574 --> 01:23:00,000
heap.
So, I'll refer you to the book.

954
01:23:00,000 --> 01:23:04,934
The best algorithm to date with
this problem is done by our own

955
01:23:04,934 --> 01:23:09,233
David Karger on the faculty here
with one of our former

956
01:23:09,233 --> 01:23:12,975
graduates, Phil Kline,
who is now a professor at

957
01:23:12,975 --> 01:23:17,353
Brown, and Robert Tarjan,
who is sort of like the master

958
01:23:17,353 --> 01:23:22,368
of all data structures who was a
professor at Princeton in 1993.

959
01:23:22,368 --> 01:23:26,189
OK, it's a randomized
algorithm, and it gives you

960
01:23:26,189 --> 01:23:32,000
order V plus E expected time.
OK, so that's the best to date.

961
01:23:32,000 --> 01:23:36,300
It's still open as to whether
there is a deterministic,

962
01:23:36,300 --> 01:23:40,679
there is worst-case bound,
whether there is a worst-case

963
01:23:40,679 --> 01:23:45,059
bound that is linear time.
OK, but there is a randomized

964
01:23:45,059 --> 01:23:47,369
to linear time,
and otherwise,

965
01:23:47,369 --> 01:23:51,509
this is essentially the best
bound without additional

966
01:23:51,509 --> 01:23:54,058
assumptions.
OK, very cool stuff.

967
01:23:54,058 --> 01:23:58,675
Next, we're going to see a lot
of these ideas of greedy and

968
01:23:58,675 --> 01:24:01,000
dynamic programming in practice.